/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import { Listener, Provider } from '@ethersproject/providers';
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export interface MarketplaceInterface extends utils.Interface {
  functions: {
    'DEFAULT_ADMIN_ROLE()': FunctionFragment;
    'META_TX_FORWARDER()': FunctionFragment;
    'freeport()': FunctionFragment;
    'getGlobalNftId(uint32)': FunctionFragment;
    'getRoleAdmin(bytes32)': FunctionFragment;
    'grantRole(bytes32,address)': FunctionFragment;
    'hasRole(bytes32,address)': FunctionFragment;
    'isTrustedForwarder(address)': FunctionFragment;
    'renounceRole(bytes32,address)': FunctionFragment;
    'revokeRole(bytes32,address)': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'upgradeTo(address)': FunctionFragment;
    'upgradeToAndCall(address,bytes)': FunctionFragment;
    'initialize(address)': FunctionFragment;
    'makeOffer(uint256,uint256)': FunctionFragment;
    'getOffer(address,uint256)': FunctionFragment;
    'takeOffer(address,address,uint256,uint256,uint256)': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'META_TX_FORWARDER',
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: 'freeport', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getGlobalNftId',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoleAdmin',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'grantRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'hasRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'isTrustedForwarder',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'renounceRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'revokeRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'upgradeTo', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'upgradeToAndCall',
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'initialize', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'makeOffer',
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getOffer',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'takeOffer',
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'META_TX_FORWARDER',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'freeport', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getGlobalNftId',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoleAdmin',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'grantRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'isTrustedForwarder',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'renounceRole',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'revokeRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'upgradeTo', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'upgradeToAndCall',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'makeOffer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOffer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'takeOffer', data: BytesLike): Result;

  events: {
    'AdminChanged(address,address)': EventFragment;
    'BeaconUpgraded(address)': EventFragment;
    'MakeOffer(address,uint256,uint256)': EventFragment;
    'RoleAdminChanged(bytes32,bytes32,bytes32)': EventFragment;
    'RoleGranted(bytes32,address,address)': EventFragment;
    'RoleRevoked(bytes32,address,address)': EventFragment;
    'TakeOffer(address,address,uint256,uint256,uint256)': EventFragment;
    'TransferSingle(address,address,address,uint256,uint256)': EventFragment;
    'Upgraded(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BeaconUpgraded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MakeOffer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleAdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleGranted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleRevoked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TakeOffer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferSingle'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Upgraded'): EventFragment;
}

export type AdminChangedEvent = TypedEvent<
  [string, string],
  { previousAdmin: string; newAdmin: string }
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export type BeaconUpgradedEvent = TypedEvent<[string], { beacon: string }>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export type MakeOfferEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  { seller: string; nftId: BigNumber; price: BigNumber }
>;

export type MakeOfferEventFilter = TypedEventFilter<MakeOfferEvent>;

export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  { role: string; previousAdminRole: string; newAdminRole: string }
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export type TakeOfferEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber],
  {
    buyer: string;
    seller: string;
    nftId: BigNumber;
    price: BigNumber;
    amount: BigNumber;
  }
>;

export type TakeOfferEventFilter = TypedEventFilter<TakeOfferEvent>;

export type TransferSingleEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    operator: string;
    from: string;
    to: string;
    id: BigNumber;
    value: BigNumber;
  }
>;

export type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;

export type UpgradedEvent = TypedEvent<[string], { implementation: string }>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface Marketplace extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MarketplaceInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<[string]>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<[string]>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<[string]>;

    freeport(overrides?: CallOverrides): Promise<[string]>;

    'freeport()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * See {IERC165-supportsInterface}.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    initialize(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'initialize(address)'(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

  META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

  'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

  freeport(overrides?: CallOverrides): Promise<string>;

  'freeport()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Calculate the global ID of an NFT type, identifying its inner nft id.
   */
  getGlobalNftId(
    innerNftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Calculate the global ID of an NFT type, identifying its inner nft id.
   */
  'getGlobalNftId(uint32)'(
    innerNftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  'getRoleAdmin(bytes32)'(
    role: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  grantRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'grantRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  hasRole(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  'hasRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTrustedForwarder(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  'isTrustedForwarder(address)'(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  renounceRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  'renounceRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  revokeRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'revokeRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC165-supportsInterface}.
   */
  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * See {IERC165-supportsInterface}.
   */
  'supportsInterface(bytes4)'(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  upgradeTo(
    newImplementation: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'upgradeTo(address)'(
    newImplementation: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'upgradeToAndCall(address,bytes)'(
    newImplementation: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  initialize(
    _freeport: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'initialize(address)'(
    _freeport: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
   */
  makeOffer(
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
   */
  'makeOffer(uint256,uint256)'(
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Return the price offered by the given seller for the given NFT type.
   */
  getOffer(
    seller: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Return the price offered by the given seller for the given NFT type.
   */
  'getOffer(address,uint256)'(
    seller: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
   */
  takeOffer(
    buyer: string,
    seller: string,
    nftId: BigNumberish,
    expectedPriceOrZero: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
   */
  'takeOffer(address,address,uint256,uint256,uint256)'(
    buyer: string,
    seller: string,
    nftId: BigNumberish,
    expectedPriceOrZero: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

    freeport(overrides?: CallOverrides): Promise<string>;

    'freeport()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC165-supportsInterface}.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    upgradeTo(
      newImplementation: string,
      overrides?: CallOverrides
    ): Promise<void>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(_freeport: string, overrides?: CallOverrides): Promise<void>;

    'initialize(address)'(
      _freeport: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    'AdminChanged(address,address)'(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    'BeaconUpgraded(address)'(
      beacon?: string | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(beacon?: string | null): BeaconUpgradedEventFilter;

    'MakeOffer(address,uint256,uint256)'(
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null
    ): MakeOfferEventFilter;
    MakeOffer(
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null
    ): MakeOfferEventFilter;

    'RoleAdminChanged(bytes32,bytes32,bytes32)'(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;

    'RoleGranted(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;

    'RoleRevoked(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;

    'TakeOffer(address,address,uint256,uint256,uint256)'(
      buyer?: string | null,
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null,
      amount?: null
    ): TakeOfferEventFilter;
    TakeOffer(
      buyer?: string | null,
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null,
      amount?: null
    ): TakeOfferEventFilter;

    'TransferSingle(address,address,address,uint256,uint256)'(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;
    TransferSingle(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;

    'Upgraded(address)'(implementation?: string | null): UpgradedEventFilter;
    Upgraded(implementation?: string | null): UpgradedEventFilter;
  };

  estimateGas: {
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<BigNumber>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<BigNumber>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<BigNumber>;

    freeport(overrides?: CallOverrides): Promise<BigNumber>;

    'freeport()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC165-supportsInterface}.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    initialize(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'initialize(address)'(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'DEFAULT_ADMIN_ROLE()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'META_TX_FORWARDER()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    freeport(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'freeport()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC165-supportsInterface}.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'initialize(address)'(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender must have "approved" this contract in the ERC20 contract. The seller receives ERC20. The buyer receives the NFT. The sender is not necessarily the same as buyer, see FiatGateway. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
