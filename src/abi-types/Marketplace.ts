/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import { Listener, Provider } from '@ethersproject/providers';
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export interface MarketplaceInterface extends utils.Interface {
  functions: {
    'CURRENCY()': FunctionFragment;
    'DEFAULT_ADMIN_ROLE()': FunctionFragment;
    'META_TX_FORWARDER()': FunctionFragment;
    'balanceOf(address,uint256)': FunctionFragment;
    'balanceOfBatch(address[],uint256[])': FunctionFragment;
    'currencyContract()': FunctionFragment;
    'deposit(uint256)': FunctionFragment;
    'freeport()': FunctionFragment;
    'getGlobalNftId(uint32)': FunctionFragment;
    'getRoleAdmin(bytes32)': FunctionFragment;
    'grantRole(bytes32,address)': FunctionFragment;
    'hasRole(bytes32,address)': FunctionFragment;
    'isApprovedForAll(address,address)': FunctionFragment;
    'isTrustedForwarder(address)': FunctionFragment;
    'renounceRole(bytes32,address)': FunctionFragment;
    'revokeRole(bytes32,address)': FunctionFragment;
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)': FunctionFragment;
    'safeTransferFrom(address,address,uint256,uint256,bytes)': FunctionFragment;
    'setApprovalForAll(address,bool)': FunctionFragment;
    'setERC20(address)': FunctionFragment;
    'setURI(string)': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'transferFrom(address,address,uint256,uint256)': FunctionFragment;
    'upgradeTo(address)': FunctionFragment;
    'upgradeToAndCall(address,bytes)': FunctionFragment;
    'uri(uint256)': FunctionFragment;
    'withdraw(uint256)': FunctionFragment;
    'initialize(address)': FunctionFragment;
    'makeOffer(uint256,uint256)': FunctionFragment;
    'getOffer(address,uint256)': FunctionFragment;
    'takeOffer(address,address,uint256,uint256,uint256)': FunctionFragment;
  };

  encodeFunctionData(functionFragment: 'CURRENCY', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'META_TX_FORWARDER',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOf',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOfBatch',
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'currencyContract',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'freeport', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getGlobalNftId',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoleAdmin',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'grantRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'hasRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'isApprovedForAll',
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'isTrustedForwarder',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'renounceRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'revokeRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'safeBatchTransferFrom',
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'safeTransferFrom',
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'setApprovalForAll',
    values: [string, boolean]
  ): string;
  encodeFunctionData(functionFragment: 'setERC20', values: [string]): string;
  encodeFunctionData(functionFragment: 'setURI', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'transferFrom',
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'upgradeTo', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'upgradeToAndCall',
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'uri', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'initialize', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'makeOffer',
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getOffer',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'takeOffer',
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: 'CURRENCY', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'META_TX_FORWARDER',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'balanceOfBatch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'currencyContract',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'freeport', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getGlobalNftId',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoleAdmin',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'grantRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'isApprovedForAll',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isTrustedForwarder',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'renounceRole',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'revokeRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'safeBatchTransferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'safeTransferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setApprovalForAll',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'setERC20', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'setURI', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'transferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'upgradeTo', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'upgradeToAndCall',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'uri', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'makeOffer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOffer', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'takeOffer', data: BytesLike): Result;

  events: {
    'AdminChanged(address,address)': EventFragment;
    'ApprovalForAll(address,address,bool)': EventFragment;
    'BeaconUpgraded(address)': EventFragment;
    'MakeOffer(address,uint256,uint256)': EventFragment;
    'RoleAdminChanged(bytes32,bytes32,bytes32)': EventFragment;
    'RoleGranted(bytes32,address,address)': EventFragment;
    'RoleRevoked(bytes32,address,address)': EventFragment;
    'TakeOffer(address,address,uint256,uint256,uint256)': EventFragment;
    'TransferBatch(address,address,address,uint256[],uint256[])': EventFragment;
    'TransferSingle(address,address,address,uint256,uint256)': EventFragment;
    'URI(string,uint256)': EventFragment;
    'Upgraded(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BeaconUpgraded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MakeOffer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleAdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleGranted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleRevoked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TakeOffer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferBatch'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferSingle'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'URI'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Upgraded'): EventFragment;
}

export type AdminChangedEvent = TypedEvent<
  [string, string],
  { previousAdmin: string; newAdmin: string }
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export type ApprovalForAllEvent = TypedEvent<
  [string, string, boolean],
  { account: string; operator: string; approved: boolean }
>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export type BeaconUpgradedEvent = TypedEvent<[string], { beacon: string }>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export type MakeOfferEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  { seller: string; nftId: BigNumber; price: BigNumber }
>;

export type MakeOfferEventFilter = TypedEventFilter<MakeOfferEvent>;

export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  { role: string; previousAdminRole: string; newAdminRole: string }
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export type TakeOfferEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber],
  {
    buyer: string;
    seller: string;
    nftId: BigNumber;
    price: BigNumber;
    amount: BigNumber;
  }
>;

export type TakeOfferEventFilter = TypedEventFilter<TakeOfferEvent>;

export type TransferBatchEvent = TypedEvent<
  [string, string, string, BigNumber[], BigNumber[]],
  {
    operator: string;
    from: string;
    to: string;
    ids: BigNumber[];
    values: BigNumber[];
  }
>;

export type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;

export type TransferSingleEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    operator: string;
    from: string;
    to: string;
    id: BigNumber;
    value: BigNumber;
  }
>;

export type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;

export type URIEvent = TypedEvent<
  [string, BigNumber],
  { value: string; id: BigNumber }
>;

export type URIEventFilter = TypedEventFilter<URIEvent>;

export type UpgradedEvent = TypedEvent<[string], { implementation: string }>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface Marketplace extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MarketplaceInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * The token ID that represents the internal currency for all payments in this contract.
     */
    CURRENCY(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The token ID that represents the internal currency for all payments in this contract.
     */
    'CURRENCY()'(overrides?: CallOverrides): Promise<[BigNumber]>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<[string]>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<[string]>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * The address of ERC-20 token's contract
     */
    currencyContract(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The address of ERC-20 token's contract
     */
    'currencyContract()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
     */
    deposit(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
     */
    'deposit(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    freeport(overrides?: CallOverrides): Promise<[string]>;

    'freeport()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
     */
    setERC20(
      _currencyContract: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
     */
    'setERC20(address)'(
      _currencyContract: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setURI(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'setURI(string)'(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Withdraw currency from internal to ERC20
     */
    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Withdraw currency from internal to ERC20
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    initialize(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'initialize(address)'(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  /**
   * The token ID that represents the internal currency for all payments in this contract.
   */
  CURRENCY(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The token ID that represents the internal currency for all payments in this contract.
   */
  'CURRENCY()'(overrides?: CallOverrides): Promise<BigNumber>;

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

  META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

  'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

  /**
   * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
   */
  balanceOf(
    account: string,
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
   */
  'balanceOf(address,uint256)'(
    account: string,
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
   */
  balanceOfBatch(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
   */
  'balanceOfBatch(address[],uint256[])'(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * The address of ERC-20 token's contract
   */
  currencyContract(overrides?: CallOverrides): Promise<string>;

  /**
   * The address of ERC-20 token's contract
   */
  'currencyContract()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
   */
  deposit(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
   */
  'deposit(uint256)'(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  freeport(overrides?: CallOverrides): Promise<string>;

  'freeport()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Calculate the global ID of an NFT type, identifying its inner nft id.
   */
  getGlobalNftId(
    innerNftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Calculate the global ID of an NFT type, identifying its inner nft id.
   */
  'getGlobalNftId(uint32)'(
    innerNftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  'getRoleAdmin(bytes32)'(
    role: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  grantRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'grantRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  hasRole(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  'hasRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * See {IERC1155-isApprovedForAll}.
   */
  isApprovedForAll(
    account: string,
    operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * See {IERC1155-isApprovedForAll}.
   */
  'isApprovedForAll(address,address)'(
    account: string,
    operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTrustedForwarder(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  'isTrustedForwarder(address)'(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  renounceRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  'renounceRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  revokeRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'revokeRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeBatchTransferFrom}.
   */
  safeBatchTransferFrom(
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeBatchTransferFrom}.
   */
  'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeTransferFrom}.
   */
  safeTransferFrom(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeTransferFrom}.
   */
  'safeTransferFrom(address,address,uint256,uint256,bytes)'(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-setApprovalForAll}.
   */
  setApprovalForAll(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-setApprovalForAll}.
   */
  'setApprovalForAll(address,bool)'(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
   */
  setERC20(
    _currencyContract: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
   */
  'setERC20(address)'(
    _currencyContract: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setURI(
    newuri: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'setURI(string)'(
    newuri: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
   */
  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
   */
  'supportsInterface(bytes4)'(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
   */
  transferFrom(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
   */
  'transferFrom(address,address,uint256,uint256)'(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'upgradeTo(address)'(
    newImplementation: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'upgradeToAndCall(address,bytes)'(
    newImplementation: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
   */
  uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
   */
  'uri(uint256)'(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Withdraw currency from internal to ERC20
   */
  withdraw(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Withdraw currency from internal to ERC20
   */
  'withdraw(uint256)'(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  initialize(
    _freeport: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'initialize(address)'(
    _freeport: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
   */
  makeOffer(
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
   */
  'makeOffer(uint256,uint256)'(
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Return the price offered by the given seller for the given NFT type.
   */
  getOffer(
    seller: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Return the price offered by the given seller for the given NFT type.
   */
  'getOffer(address,uint256)'(
    seller: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
   */
  takeOffer(
    buyer: string,
    seller: string,
    nftId: BigNumberish,
    expectedPriceOrZero: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
   */
  'takeOffer(address,address,uint256,uint256,uint256)'(
    buyer: string,
    seller: string,
    nftId: BigNumberish,
    expectedPriceOrZero: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * The token ID that represents the internal currency for all payments in this contract.
     */
    CURRENCY(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The token ID that represents the internal currency for all payments in this contract.
     */
    'CURRENCY()'(overrides?: CallOverrides): Promise<BigNumber>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * The address of ERC-20 token's contract
     */
    currencyContract(overrides?: CallOverrides): Promise<string>;

    /**
     * The address of ERC-20 token's contract
     */
    'currencyContract()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
     */
    deposit(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
     */
    'deposit(uint256)'(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    freeport(overrides?: CallOverrides): Promise<string>;

    'freeport()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
     */
    setERC20(
      _currencyContract: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
     */
    'setERC20(address)'(
      _currencyContract: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setURI(newuri: string, overrides?: CallOverrides): Promise<void>;

    'setURI(string)'(newuri: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      newImplementation: string,
      overrides?: CallOverrides
    ): Promise<void>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Withdraw currency from internal to ERC20
     */
    withdraw(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Withdraw currency from internal to ERC20
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(_freeport: string, overrides?: CallOverrides): Promise<void>;

    'initialize(address)'(
      _freeport: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    'AdminChanged(address,address)'(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    'ApprovalForAll(address,address,bool)'(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter;

    'BeaconUpgraded(address)'(
      beacon?: string | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(beacon?: string | null): BeaconUpgradedEventFilter;

    'MakeOffer(address,uint256,uint256)'(
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null
    ): MakeOfferEventFilter;
    MakeOffer(
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null
    ): MakeOfferEventFilter;

    'RoleAdminChanged(bytes32,bytes32,bytes32)'(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;

    'RoleGranted(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;

    'RoleRevoked(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;

    'TakeOffer(address,address,uint256,uint256,uint256)'(
      buyer?: string | null,
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null,
      amount?: null
    ): TakeOfferEventFilter;
    TakeOffer(
      buyer?: string | null,
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null,
      amount?: null
    ): TakeOfferEventFilter;

    'TransferBatch(address,address,address,uint256[],uint256[])'(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;
    TransferBatch(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;

    'TransferSingle(address,address,address,uint256,uint256)'(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;
    TransferSingle(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;

    'URI(string,uint256)'(
      value?: null,
      id?: BigNumberish | null
    ): URIEventFilter;
    URI(value?: null, id?: BigNumberish | null): URIEventFilter;

    'Upgraded(address)'(implementation?: string | null): UpgradedEventFilter;
    Upgraded(implementation?: string | null): UpgradedEventFilter;
  };

  estimateGas: {
    /**
     * The token ID that represents the internal currency for all payments in this contract.
     */
    CURRENCY(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The token ID that represents the internal currency for all payments in this contract.
     */
    'CURRENCY()'(overrides?: CallOverrides): Promise<BigNumber>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<BigNumber>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<BigNumber>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The address of ERC-20 token's contract
     */
    currencyContract(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The address of ERC-20 token's contract
     */
    'currencyContract()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
     */
    deposit(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
     */
    'deposit(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    freeport(overrides?: CallOverrides): Promise<BigNumber>;

    'freeport()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
     */
    setERC20(
      _currencyContract: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
     */
    'setERC20(address)'(
      _currencyContract: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setURI(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'setURI(string)'(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Withdraw currency from internal to ERC20
     */
    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Withdraw currency from internal to ERC20
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    initialize(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'initialize(address)'(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * The token ID that represents the internal currency for all payments in this contract.
     */
    CURRENCY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The token ID that represents the internal currency for all payments in this contract.
     */
    'CURRENCY()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'DEFAULT_ADMIN_ROLE()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'META_TX_FORWARDER()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The address of ERC-20 token's contract
     */
    currencyContract(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The address of ERC-20 token's contract
     */
    'currencyContract()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
     */
    deposit(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Deposit currency from ERC20 into the internal currency. This requires payer to approve deposit.
     */
    'deposit(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    freeport(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'freeport()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
     */
    setERC20(
      _currencyContract: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets token's contract address. This token is used to deposit and withdraw on chain adapter's contract is deployed.
     */
    'setERC20(address)'(
      _currencyContract: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setURI(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'setURI(string)'(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraw currency from internal to ERC20
     */
    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraw currency from internal to ERC20
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'initialize(address)'(
      _freeport: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The sender pays ERC20. The sender is not necessarily the same as buyer, see FiatGateway. The seller receives internal currency (equivalent to the ERC20 payment, see the function withdraw). The buyer receives the NFT. The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      expectedPriceOrZero: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
