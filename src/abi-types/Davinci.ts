/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from 'ethers';
import { BytesLike } from '@ethersproject/bytes';
import { Listener, Provider } from '@ethersproject/providers';
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from './common';

export interface DavinciInterface extends ethers.utils.Interface {
  functions: {
    'BASIS_POINTS()': FunctionFragment;
    'BYPASS_SENDER()': FunctionFragment;
    'CURRENCY()': FunctionFragment;
    'CURRENCY_SUPPLY()': FunctionFragment;
    'DEFAULT_ADMIN_ROLE()': FunctionFragment;
    'MAX_JOINT_ACCOUNT_SHARES()': FunctionFragment;
    'META_TX_FORWARDER()': FunctionFragment;
    'TRANSFER_OPERATOR()': FunctionFragment;
    'balanceOf(address,uint256)': FunctionFragment;
    'balanceOfBatch(address[],uint256[])': FunctionFragment;
    'balanceOfJAOwner(address,address)': FunctionFragment;
    'childChainManagerProxy()': FunctionFragment;
    'configureRoyalties(uint256,address,uint256,uint256,address,uint256,uint256)': FunctionFragment;
    'createJointAccount(address[],uint256[])': FunctionFragment;
    'currencyInBridge()': FunctionFragment;
    'deposit(address,bytes)': FunctionFragment;
    'distributeJointAccount(address)': FunctionFragment;
    'fractionOfJAOwner(address,address)': FunctionFragment;
    'getNftId(address,uint32,uint64)': FunctionFragment;
    'getOffer(address,uint256)': FunctionFragment;
    'getRoleAdmin(bytes32)': FunctionFragment;
    'getRoyalties(uint256)': FunctionFragment;
    'getRoyaltiesForBeneficiary(uint256,address)': FunctionFragment;
    'grantRole(bytes32,address)': FunctionFragment;
    'hasRole(bytes32,address)': FunctionFragment;
    'isApprovedForAll(address,address)': FunctionFragment;
    'isTrustedForwarder(address)': FunctionFragment;
    'issuanceNonces(address)': FunctionFragment;
    'issue(uint64,bytes)': FunctionFragment;
    'jointAccounts(address,uint256)': FunctionFragment;
    'lockRoyalties(uint256,uint256)': FunctionFragment;
    'makeAddressOfJointAccount(address[],uint256[])': FunctionFragment;
    'makeOffer(uint256,uint256)': FunctionFragment;
    'renounceRole(bytes32,address)': FunctionFragment;
    'revokeRole(bytes32,address)': FunctionFragment;
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)': FunctionFragment;
    'safeTransferFrom(address,address,uint256,uint256,bytes)': FunctionFragment;
    'setApprovalForAll(address,bool)': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'takeOffer(address,address,uint256,uint256,uint256)': FunctionFragment;
    'updateChildChainManager(address)': FunctionFragment;
    'uri(uint256)': FunctionFragment;
    'withdraw(uint256)': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'BASIS_POINTS',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'BYPASS_SENDER',
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: 'CURRENCY', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'CURRENCY_SUPPLY',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'MAX_JOINT_ACCOUNT_SHARES',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'META_TX_FORWARDER',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'TRANSFER_OPERATOR',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOf',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOfBatch',
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOfJAOwner',
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'childChainManagerProxy',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'configureRoyalties',
    values: [
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'createJointAccount',
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'currencyInBridge',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'distributeJointAccount',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'fractionOfJAOwner',
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'getNftId',
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getOffer',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoleAdmin',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoyalties',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoyaltiesForBeneficiary',
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'grantRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'hasRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'isApprovedForAll',
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'isTrustedForwarder',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'issuanceNonces',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'issue',
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'jointAccounts',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'lockRoyalties',
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'makeAddressOfJointAccount',
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'makeOffer',
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'renounceRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'revokeRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'safeBatchTransferFrom',
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'safeTransferFrom',
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'setApprovalForAll',
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'takeOffer',
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'updateChildChainManager',
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: 'uri', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: 'BASIS_POINTS',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'BYPASS_SENDER',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'CURRENCY', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'CURRENCY_SUPPLY',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'MAX_JOINT_ACCOUNT_SHARES',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'META_TX_FORWARDER',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'TRANSFER_OPERATOR',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'balanceOfBatch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'balanceOfJAOwner',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'childChainManagerProxy',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'configureRoyalties',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'createJointAccount',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'currencyInBridge',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'distributeJointAccount',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'fractionOfJAOwner',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'getNftId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getOffer', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getRoleAdmin',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoyalties',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoyaltiesForBeneficiary',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'grantRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'isApprovedForAll',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isTrustedForwarder',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'issuanceNonces',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'issue', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'jointAccounts',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'lockRoyalties',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'makeAddressOfJointAccount',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'makeOffer', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'renounceRole',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'revokeRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'safeBatchTransferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'safeTransferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setApprovalForAll',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'takeOffer', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'updateChildChainManager',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'uri', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;

  events: {
    'ApprovalForAll(address,address,bool)': EventFragment;
    'JointAccountShareCreated(address,address,uint256)': EventFragment;
    'MakeOffer(address,uint256,uint256)': EventFragment;
    'RoleAdminChanged(bytes32,bytes32,bytes32)': EventFragment;
    'RoleGranted(bytes32,address,address)': EventFragment;
    'RoleRevoked(bytes32,address,address)': EventFragment;
    'RoyaltiesConfigured(uint256,address,uint256,uint256,address,uint256,uint256)': EventFragment;
    'RoyaltiesLocked(uint256,uint256)': EventFragment;
    'TakeOffer(address,address,uint256,uint256,uint256)': EventFragment;
    'Transfer(address,address,uint256)': EventFragment;
    'TransferBatch(address,address,address,uint256[],uint256[])': EventFragment;
    'TransferSingle(address,address,address,uint256,uint256)': EventFragment;
    'URI(string,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'JointAccountShareCreated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MakeOffer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleAdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleGranted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleRevoked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoyaltiesConfigured'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoyaltiesLocked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TakeOffer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferBatch'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferSingle'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'URI'): EventFragment;
}

export type ApprovalForAllEvent = TypedEvent<
  [string, string, boolean],
  { account: string; operator: string; approved: boolean }
>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export type JointAccountShareCreatedEvent = TypedEvent<
  [string, string, BigNumber],
  { account: string; owner: string; fraction: BigNumber }
>;

export type JointAccountShareCreatedEventFilter =
  TypedEventFilter<JointAccountShareCreatedEvent>;

export type MakeOfferEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  { seller: string; nftId: BigNumber; price: BigNumber }
>;

export type MakeOfferEventFilter = TypedEventFilter<MakeOfferEvent>;

export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  { role: string; previousAdminRole: string; newAdminRole: string }
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export type RoyaltiesConfiguredEvent = TypedEvent<
  [BigNumber, string, BigNumber, BigNumber, string, BigNumber, BigNumber],
  {
    nftId: BigNumber;
    primaryRoyaltyAccount: string;
    primaryRoyaltyCut: BigNumber;
    primaryRoyaltyMinimum: BigNumber;
    secondaryRoyaltyAccount: string;
    secondaryRoyaltyCut: BigNumber;
    secondaryRoyaltyMinimum: BigNumber;
  }
>;

export type RoyaltiesConfiguredEventFilter =
  TypedEventFilter<RoyaltiesConfiguredEvent>;

export type RoyaltiesLockedEvent = TypedEvent<
  [BigNumber, BigNumber],
  { nftId: BigNumber; lockUntil: BigNumber }
>;

export type RoyaltiesLockedEventFilter = TypedEventFilter<RoyaltiesLockedEvent>;

export type TakeOfferEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber],
  {
    buyer: string;
    seller: string;
    nftId: BigNumber;
    price: BigNumber;
    amount: BigNumber;
  }
>;

export type TakeOfferEventFilter = TypedEventFilter<TakeOfferEvent>;

export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  { from: string; to: string; value: BigNumber }
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export type TransferBatchEvent = TypedEvent<
  [string, string, string, BigNumber[], BigNumber[]],
  {
    operator: string;
    from: string;
    to: string;
    ids: BigNumber[];
    values: BigNumber[];
  }
>;

export type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;

export type TransferSingleEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    operator: string;
    from: string;
    to: string;
    id: BigNumber;
    value: BigNumber;
  }
>;

export type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;

export type URIEvent = TypedEvent<
  [string, BigNumber],
  { value: string; id: BigNumber }
>;

export type URIEventFilter = TypedEventFilter<URIEvent>;

export interface Davinci extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: DavinciInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * The total fraction representing 100% of an account.
     */
    BASIS_POINTS(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The total fraction representing 100% of an account.
     */
    'BASIS_POINTS()'(overrides?: CallOverrides): Promise<[BigNumber]>;

    BYPASS_SENDER(overrides?: CallOverrides): Promise<[string]>;

    'BYPASS_SENDER()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The token ID that represents the CERE currency for all payments in this contract.
     */
    CURRENCY(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The token ID that represents the CERE currency for all payments in this contract.
     */
    'CURRENCY()'(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
     */
    CURRENCY_SUPPLY(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
     */
    'CURRENCY_SUPPLY()'(overrides?: CallOverrides): Promise<[BigNumber]>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<[string]>;

    MAX_JOINT_ACCOUNT_SHARES(overrides?: CallOverrides): Promise<[BigNumber]>;

    'MAX_JOINT_ACCOUNT_SHARES()'(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<[string]>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<[string]>;

    TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<[string]>;

    'TRANSFER_OPERATOR()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
     */
    balanceOfJAOwner(
      account: string,
      owner: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
     */
    'balanceOfJAOwner(address,address)'(
      account: string,
      owner: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * The address of the Polygon bridge contract that is allowed to deposit tokens.
     */
    childChainManagerProxy(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The address of the Polygon bridge contract that is allowed to deposit tokens.
     */
    'childChainManagerProxy()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
     */
    configureRoyalties(
      nftId: BigNumberish,
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
     */
    'configureRoyalties(uint256,address,uint256,uint256,address,uint256,uint256)'(
      nftId: BigNumberish,
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
     */
    createJointAccount(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
     */
    'createJointAccount(address[],uint256[])'(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Return the total amount of currency available in the bridge, which can be deposited into this contract.
     */
    currencyInBridge(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Return the total amount of currency available in the bridge, which can be deposited into this contract.
     */
    'currencyInBridge()'(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
     */
    deposit(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
     */
    'deposit(address,bytes)'(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
     */
    distributeJointAccount(
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
     */
    'distributeJointAccount(address)'(
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
     */
    fractionOfJAOwner(
      account: string,
      maybeOwner: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
     */
    'fractionOfJAOwner(address,address)'(
      account: string,
      maybeOwner: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
     */
    getNftId(
      issuer: string,
      nonce: BigNumberish,
      supply: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
     */
    'getNftId(address,uint32,uint64)'(
      issuer: string,
      nonce: BigNumberish,
      supply: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
     */
    getRoyalties(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
     */
    'getRoyalties(uint256)'(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      nftId: BigNumberish,
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(uint256,address)'(
      nftId: BigNumberish,
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
     */
    issuanceNonces(arg0: string, overrides?: CallOverrides): Promise<[number]>;

    /**
     * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
     */
    'issuanceNonces(address)'(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[number]>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    issue(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    'issue(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    jointAccounts(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { owner: string; fraction: BigNumber }>;

    'jointAccounts(address,uint256)'(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { owner: string; fraction: BigNumber }>;

    /**
     * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
     */
    lockRoyalties(
      nftId: BigNumberish,
      lockUntil: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
     */
    'lockRoyalties(uint256,uint256)'(
      nftId: BigNumberish,
      lockUntil: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
     */
    makeAddressOfJointAccount(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
     */
    'makeAddressOfJointAccount(address[],uint256[])'(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      price: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      price: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
     */
    updateChildChainManager(
      newChildChainManagerProxy: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
     */
    'updateChildChainManager(address)'(
      newChildChainManagerProxy: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
     */
    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  /**
   * The total fraction representing 100% of an account.
   */
  BASIS_POINTS(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The total fraction representing 100% of an account.
   */
  'BASIS_POINTS()'(overrides?: CallOverrides): Promise<BigNumber>;

  BYPASS_SENDER(overrides?: CallOverrides): Promise<string>;

  'BYPASS_SENDER()'(overrides?: CallOverrides): Promise<string>;

  /**
   * The token ID that represents the CERE currency for all payments in this contract.
   */
  CURRENCY(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The token ID that represents the CERE currency for all payments in this contract.
   */
  'CURRENCY()'(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
   */
  CURRENCY_SUPPLY(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
   */
  'CURRENCY_SUPPLY()'(overrides?: CallOverrides): Promise<BigNumber>;

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

  MAX_JOINT_ACCOUNT_SHARES(overrides?: CallOverrides): Promise<BigNumber>;

  'MAX_JOINT_ACCOUNT_SHARES()'(overrides?: CallOverrides): Promise<BigNumber>;

  META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

  'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

  TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<string>;

  'TRANSFER_OPERATOR()'(overrides?: CallOverrides): Promise<string>;

  /**
   * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
   */
  balanceOf(
    account: string,
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
   */
  'balanceOf(address,uint256)'(
    account: string,
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
   */
  balanceOfBatch(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
   */
  'balanceOfBatch(address[],uint256[])'(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
   */
  balanceOfJAOwner(
    account: string,
    owner: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
   */
  'balanceOfJAOwner(address,address)'(
    account: string,
    owner: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * The address of the Polygon bridge contract that is allowed to deposit tokens.
   */
  childChainManagerProxy(overrides?: CallOverrides): Promise<string>;

  /**
   * The address of the Polygon bridge contract that is allowed to deposit tokens.
   */
  'childChainManagerProxy()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
   */
  configureRoyalties(
    nftId: BigNumberish,
    primaryRoyaltyAccount: string,
    primaryRoyaltyCut: BigNumberish,
    primaryRoyaltyMinimum: BigNumberish,
    secondaryRoyaltyAccount: string,
    secondaryRoyaltyCut: BigNumberish,
    secondaryRoyaltyMinimum: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
   */
  'configureRoyalties(uint256,address,uint256,uint256,address,uint256,uint256)'(
    nftId: BigNumberish,
    primaryRoyaltyAccount: string,
    primaryRoyaltyCut: BigNumberish,
    primaryRoyaltyMinimum: BigNumberish,
    secondaryRoyaltyAccount: string,
    secondaryRoyaltyCut: BigNumberish,
    secondaryRoyaltyMinimum: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
   */
  createJointAccount(
    owners: string[],
    fractions: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
   */
  'createJointAccount(address[],uint256[])'(
    owners: string[],
    fractions: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Return the total amount of currency available in the bridge, which can be deposited into this contract.
   */
  currencyInBridge(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Return the total amount of currency available in the bridge, which can be deposited into this contract.
   */
  'currencyInBridge()'(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
   */
  deposit(
    user: string,
    depositData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
   */
  'deposit(address,bytes)'(
    user: string,
    depositData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
   */
  distributeJointAccount(
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
   */
  'distributeJointAccount(address)'(
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
   */
  fractionOfJAOwner(
    account: string,
    maybeOwner: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
   */
  'fractionOfJAOwner(address,address)'(
    account: string,
    maybeOwner: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
   */
  getNftId(
    issuer: string,
    nonce: BigNumberish,
    supply: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
   */
  'getNftId(address,uint32,uint64)'(
    issuer: string,
    nonce: BigNumberish,
    supply: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Return the price offered by the given seller for the given NFT type.
   */
  getOffer(
    seller: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Return the price offered by the given seller for the given NFT type.
   */
  'getOffer(address,uint256)'(
    seller: string,
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  'getRoleAdmin(bytes32)'(
    role: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
   */
  getRoyalties(
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
      primaryRoyaltyAccount: string;
      primaryRoyaltyCut: BigNumber;
      primaryRoyaltyMinimum: BigNumber;
      secondaryRoyaltyAccount: string;
      secondaryRoyaltyCut: BigNumber;
      secondaryRoyaltyMinimum: BigNumber;
    }
  >;

  /**
   * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
   */
  'getRoyalties(uint256)'(
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
      primaryRoyaltyAccount: string;
      primaryRoyaltyCut: BigNumber;
      primaryRoyaltyMinimum: BigNumber;
      secondaryRoyaltyAccount: string;
      secondaryRoyaltyCut: BigNumber;
      secondaryRoyaltyMinimum: BigNumber;
    }
  >;

  /**
   * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
   */
  getRoyaltiesForBeneficiary(
    nftId: BigNumberish,
    beneficiary: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      primaryCut: BigNumber;
      primaryMinimum: BigNumber;
      secondaryCut: BigNumber;
      secondaryMinimum: BigNumber;
    }
  >;

  /**
   * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
   */
  'getRoyaltiesForBeneficiary(uint256,address)'(
    nftId: BigNumberish,
    beneficiary: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      primaryCut: BigNumber;
      primaryMinimum: BigNumber;
      secondaryCut: BigNumber;
      secondaryMinimum: BigNumber;
    }
  >;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  grantRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'grantRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  hasRole(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  'hasRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
   */
  isApprovedForAll(
    account: string,
    operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
   */
  'isApprovedForAll(address,address)'(
    account: string,
    operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTrustedForwarder(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  'isTrustedForwarder(address)'(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
   */
  issuanceNonces(arg0: string, overrides?: CallOverrides): Promise<number>;

  /**
   * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
   */
  'issuanceNonces(address)'(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
   */
  issue(
    supply: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
   */
  'issue(uint64,bytes)'(
    supply: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  jointAccounts(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, BigNumber] & { owner: string; fraction: BigNumber }>;

  'jointAccounts(address,uint256)'(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, BigNumber] & { owner: string; fraction: BigNumber }>;

  /**
   * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
   */
  lockRoyalties(
    nftId: BigNumberish,
    lockUntil: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
   */
  'lockRoyalties(uint256,uint256)'(
    nftId: BigNumberish,
    lockUntil: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
   */
  makeAddressOfJointAccount(
    owners: string[],
    fractions: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
   */
  'makeAddressOfJointAccount(address[],uint256[])'(
    owners: string[],
    fractions: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
   */
  makeOffer(
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
   */
  'makeOffer(uint256,uint256)'(
    nftId: BigNumberish,
    price: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  renounceRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  'renounceRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  revokeRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'revokeRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeBatchTransferFrom}.
   */
  safeBatchTransferFrom(
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeBatchTransferFrom}.
   */
  'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeTransferFrom}.
   */
  safeTransferFrom(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeTransferFrom}.
   */
  'safeTransferFrom(address,address,uint256,uint256,bytes)'(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-setApprovalForAll}.
   */
  setApprovalForAll(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-setApprovalForAll}.
   */
  'setApprovalForAll(address,bool)'(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
   */
  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
   */
  'supportsInterface(bytes4)'(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
   */
  takeOffer(
    buyer: string,
    seller: string,
    nftId: BigNumberish,
    price: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
   */
  'takeOffer(address,address,uint256,uint256,uint256)'(
    buyer: string,
    seller: string,
    nftId: BigNumberish,
    price: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
   */
  updateChildChainManager(
    newChildChainManagerProxy: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
   */
  'updateChildChainManager(address)'(
    newChildChainManagerProxy: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
   */
  uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
   */
  'uri(uint256)'(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
   */
  withdraw(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
   */
  'withdraw(uint256)'(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * The total fraction representing 100% of an account.
     */
    BASIS_POINTS(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The total fraction representing 100% of an account.
     */
    'BASIS_POINTS()'(overrides?: CallOverrides): Promise<BigNumber>;

    BYPASS_SENDER(overrides?: CallOverrides): Promise<string>;

    'BYPASS_SENDER()'(overrides?: CallOverrides): Promise<string>;

    /**
     * The token ID that represents the CERE currency for all payments in this contract.
     */
    CURRENCY(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The token ID that represents the CERE currency for all payments in this contract.
     */
    'CURRENCY()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
     */
    CURRENCY_SUPPLY(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
     */
    'CURRENCY_SUPPLY()'(overrides?: CallOverrides): Promise<BigNumber>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

    MAX_JOINT_ACCOUNT_SHARES(overrides?: CallOverrides): Promise<BigNumber>;

    'MAX_JOINT_ACCOUNT_SHARES()'(overrides?: CallOverrides): Promise<BigNumber>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

    TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<string>;

    'TRANSFER_OPERATOR()'(overrides?: CallOverrides): Promise<string>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
     */
    balanceOfJAOwner(
      account: string,
      owner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
     */
    'balanceOfJAOwner(address,address)'(
      account: string,
      owner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The address of the Polygon bridge contract that is allowed to deposit tokens.
     */
    childChainManagerProxy(overrides?: CallOverrides): Promise<string>;

    /**
     * The address of the Polygon bridge contract that is allowed to deposit tokens.
     */
    'childChainManagerProxy()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
     */
    configureRoyalties(
      nftId: BigNumberish,
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
     */
    'configureRoyalties(uint256,address,uint256,uint256,address,uint256,uint256)'(
      nftId: BigNumberish,
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
     */
    createJointAccount(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
     */
    'createJointAccount(address[],uint256[])'(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Return the total amount of currency available in the bridge, which can be deposited into this contract.
     */
    currencyInBridge(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return the total amount of currency available in the bridge, which can be deposited into this contract.
     */
    'currencyInBridge()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
     */
    deposit(
      user: string,
      depositData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
     */
    'deposit(address,bytes)'(
      user: string,
      depositData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
     */
    distributeJointAccount(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
     */
    'distributeJointAccount(address)'(
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
     */
    fractionOfJAOwner(
      account: string,
      maybeOwner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
     */
    'fractionOfJAOwner(address,address)'(
      account: string,
      maybeOwner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
     */
    getNftId(
      issuer: string,
      nonce: BigNumberish,
      supply: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
     */
    'getNftId(address,uint32,uint64)'(
      issuer: string,
      nonce: BigNumberish,
      supply: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
     */
    getRoyalties(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
     */
    'getRoyalties(uint256)'(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      nftId: BigNumberish,
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(uint256,address)'(
      nftId: BigNumberish,
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
     */
    issuanceNonces(arg0: string, overrides?: CallOverrides): Promise<number>;

    /**
     * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
     */
    'issuanceNonces(address)'(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    issue(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    'issue(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    jointAccounts(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { owner: string; fraction: BigNumber }>;

    'jointAccounts(address,uint256)'(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { owner: string; fraction: BigNumber }>;

    /**
     * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
     */
    lockRoyalties(
      nftId: BigNumberish,
      lockUntil: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
     */
    'lockRoyalties(uint256,uint256)'(
      nftId: BigNumberish,
      lockUntil: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
     */
    makeAddressOfJointAccount(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
     */
    'makeAddressOfJointAccount(address[],uint256[])'(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      price: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      price: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
     */
    updateChildChainManager(
      newChildChainManagerProxy: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
     */
    'updateChildChainManager(address)'(
      newChildChainManagerProxy: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
     */
    withdraw(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    'ApprovalForAll(address,address,bool)'(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter;

    'JointAccountShareCreated(address,address,uint256)'(
      account?: string | null,
      owner?: string | null,
      fraction?: null
    ): JointAccountShareCreatedEventFilter;
    JointAccountShareCreated(
      account?: string | null,
      owner?: string | null,
      fraction?: null
    ): JointAccountShareCreatedEventFilter;

    'MakeOffer(address,uint256,uint256)'(
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null
    ): MakeOfferEventFilter;
    MakeOffer(
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null
    ): MakeOfferEventFilter;

    'RoleAdminChanged(bytes32,bytes32,bytes32)'(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;

    'RoleGranted(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;

    'RoleRevoked(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;

    'RoyaltiesConfigured(uint256,address,uint256,uint256,address,uint256,uint256)'(
      nftId?: BigNumberish | null,
      primaryRoyaltyAccount?: null,
      primaryRoyaltyCut?: null,
      primaryRoyaltyMinimum?: null,
      secondaryRoyaltyAccount?: null,
      secondaryRoyaltyCut?: null,
      secondaryRoyaltyMinimum?: null
    ): RoyaltiesConfiguredEventFilter;
    RoyaltiesConfigured(
      nftId?: BigNumberish | null,
      primaryRoyaltyAccount?: null,
      primaryRoyaltyCut?: null,
      primaryRoyaltyMinimum?: null,
      secondaryRoyaltyAccount?: null,
      secondaryRoyaltyCut?: null,
      secondaryRoyaltyMinimum?: null
    ): RoyaltiesConfiguredEventFilter;

    'RoyaltiesLocked(uint256,uint256)'(
      nftId?: BigNumberish | null,
      lockUntil?: null
    ): RoyaltiesLockedEventFilter;
    RoyaltiesLocked(
      nftId?: BigNumberish | null,
      lockUntil?: null
    ): RoyaltiesLockedEventFilter;

    'TakeOffer(address,address,uint256,uint256,uint256)'(
      buyer?: string | null,
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null,
      amount?: null
    ): TakeOfferEventFilter;
    TakeOffer(
      buyer?: string | null,
      seller?: string | null,
      nftId?: BigNumberish | null,
      price?: null,
      amount?: null
    ): TakeOfferEventFilter;

    'Transfer(address,address,uint256)'(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TransferEventFilter;
    Transfer(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TransferEventFilter;

    'TransferBatch(address,address,address,uint256[],uint256[])'(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;
    TransferBatch(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;

    'TransferSingle(address,address,address,uint256,uint256)'(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;
    TransferSingle(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;

    'URI(string,uint256)'(
      value?: null,
      id?: BigNumberish | null
    ): URIEventFilter;
    URI(value?: null, id?: BigNumberish | null): URIEventFilter;
  };

  estimateGas: {
    /**
     * The total fraction representing 100% of an account.
     */
    BASIS_POINTS(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The total fraction representing 100% of an account.
     */
    'BASIS_POINTS()'(overrides?: CallOverrides): Promise<BigNumber>;

    BYPASS_SENDER(overrides?: CallOverrides): Promise<BigNumber>;

    'BYPASS_SENDER()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The token ID that represents the CERE currency for all payments in this contract.
     */
    CURRENCY(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The token ID that represents the CERE currency for all payments in this contract.
     */
    'CURRENCY()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
     */
    CURRENCY_SUPPLY(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
     */
    'CURRENCY_SUPPLY()'(overrides?: CallOverrides): Promise<BigNumber>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_JOINT_ACCOUNT_SHARES(overrides?: CallOverrides): Promise<BigNumber>;

    'MAX_JOINT_ACCOUNT_SHARES()'(overrides?: CallOverrides): Promise<BigNumber>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<BigNumber>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<BigNumber>;

    TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<BigNumber>;

    'TRANSFER_OPERATOR()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
     */
    balanceOfJAOwner(
      account: string,
      owner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
     */
    'balanceOfJAOwner(address,address)'(
      account: string,
      owner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The address of the Polygon bridge contract that is allowed to deposit tokens.
     */
    childChainManagerProxy(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The address of the Polygon bridge contract that is allowed to deposit tokens.
     */
    'childChainManagerProxy()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
     */
    configureRoyalties(
      nftId: BigNumberish,
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
     */
    'configureRoyalties(uint256,address,uint256,uint256,address,uint256,uint256)'(
      nftId: BigNumberish,
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
     */
    createJointAccount(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
     */
    'createJointAccount(address[],uint256[])'(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Return the total amount of currency available in the bridge, which can be deposited into this contract.
     */
    currencyInBridge(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return the total amount of currency available in the bridge, which can be deposited into this contract.
     */
    'currencyInBridge()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
     */
    deposit(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
     */
    'deposit(address,bytes)'(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
     */
    distributeJointAccount(
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
     */
    'distributeJointAccount(address)'(
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
     */
    fractionOfJAOwner(
      account: string,
      maybeOwner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
     */
    'fractionOfJAOwner(address,address)'(
      account: string,
      maybeOwner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
     */
    getNftId(
      issuer: string,
      nonce: BigNumberish,
      supply: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
     */
    'getNftId(address,uint32,uint64)'(
      issuer: string,
      nonce: BigNumberish,
      supply: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
     */
    getRoyalties(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
     */
    'getRoyalties(uint256)'(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      nftId: BigNumberish,
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(uint256,address)'(
      nftId: BigNumberish,
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
     */
    issuanceNonces(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
     */
    'issuanceNonces(address)'(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    issue(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    'issue(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    jointAccounts(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'jointAccounts(address,uint256)'(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
     */
    lockRoyalties(
      nftId: BigNumberish,
      lockUntil: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
     */
    'lockRoyalties(uint256,uint256)'(
      nftId: BigNumberish,
      lockUntil: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
     */
    makeAddressOfJointAccount(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
     */
    'makeAddressOfJointAccount(address[],uint256[])'(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      price: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      price: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
     */
    updateChildChainManager(
      newChildChainManagerProxy: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
     */
    'updateChildChainManager(address)'(
      newChildChainManagerProxy: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
     */
    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * The total fraction representing 100% of an account.
     */
    BASIS_POINTS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The total fraction representing 100% of an account.
     */
    'BASIS_POINTS()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    BYPASS_SENDER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'BYPASS_SENDER()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The token ID that represents the CERE currency for all payments in this contract.
     */
    CURRENCY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The token ID that represents the CERE currency for all payments in this contract.
     */
    'CURRENCY()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
     */
    CURRENCY_SUPPLY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The global supply of CERE tokens on all chains. That is 10 billion tokens, with 10 decimals.
     */
    'CURRENCY_SUPPLY()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'DEFAULT_ADMIN_ROLE()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MAX_JOINT_ACCOUNT_SHARES(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'MAX_JOINT_ACCOUNT_SHARES()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'META_TX_FORWARDER()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'TRANSFER_OPERATOR()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
     */
    balanceOfJAOwner(
      account: string,
      owner: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.
     */
    'balanceOfJAOwner(address,address)'(
      account: string,
      owner: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The address of the Polygon bridge contract that is allowed to deposit tokens.
     */
    childChainManagerProxy(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The address of the Polygon bridge contract that is allowed to deposit tokens.
     */
    'childChainManagerProxy()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
     */
    configureRoyalties(
      nftId: BigNumberish,
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT. This configuration is available to the issuer of this NFT. A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance). Otherwise, it is a secondary transfer. A royalty is defined in two parts (both optional): a cut of the sale price of an NFT, and a minimum royalty per transfer. For simple transfers not attached to a price, or a too low price, the minimum royalty is charged. The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts. The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time, effectively giving up his ability to modify the royalties. See the function lockRoyalties. There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst several parties, use a Joint Account (see function createJointAccount).
     */
    'configureRoyalties(uint256,address,uint256,uint256,address,uint256,uint256)'(
      nftId: BigNumberish,
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
     */
    createJointAccount(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create an account such that multiple owners have a claim on their respective share. The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000. Anyone can create Joint Accounts including any owners.
     */
    'createJointAccount(address[],uint256[])'(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Return the total amount of currency available in the bridge, which can be deposited into this contract.
     */
    currencyInBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Return the total amount of currency available in the bridge, which can be deposited into this contract.
     */
    'currencyInBridge()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
     */
    deposit(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Deposit currency from Ethereum into a user account in this contract. This is implemented by moving tokens from the bridge account to the user account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers. There is an extra encoding necessary for the amount. In JavaScript, add this: `web3.eth.abi.encodeParameter('uint256', amount)`
     */
    'deposit(address,bytes)'(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
     */
    distributeJointAccount(
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Distribute all tokens available to all owners of a Joint Account. The function createJointAccount must be called beforehand. Anyone can trigger the distribution.
     */
    'distributeJointAccount(address)'(
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
     */
    fractionOfJAOwner(
      account: string,
      maybeOwner: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the fraction of an account owned by the given address, in basis points (1% of 1%). If the account does not exist, or if the given address is not an owner of it, this returns 0. If the owner appears more than once in the account, this reports only the first share.
     */
    'fractionOfJAOwner(address,address)'(
      account: string,
      maybeOwner: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
     */
    getNftId(
      issuer: string,
      nonce: BigNumberish,
      supply: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.
     */
    'getNftId(address,uint32,uint64)'(
      issuer: string,
      nonce: BigNumberish,
      supply: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    getOffer(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the price offered by the given seller for the given NFT type.
     */
    'getOffer(address,uint256)'(
      seller: string,
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
     */
    getRoyalties(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.
     */
    'getRoyalties(uint256)'(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      nftId: BigNumberish,
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(uint256,address)'(
      nftId: BigNumberish,
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return true for operators with the role TRANSFER_OPERATOR. Otherwise, apply the standard approval logic of ERC1155. See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
     */
    issuanceNonces(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * A counter of NFT types issued by each issuer. This is used to generate unique NFT IDs.
     */
    'issuanceNonces(address)'(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    issue(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    'issue(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    jointAccounts(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'jointAccounts(address,uint256)'(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
     */
    lockRoyalties(
      nftId: BigNumberish,
      lockUntil: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration, after which he himself will no longer be able to change the configuration, for some time, or forever. Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds). Set to 0xFFFFFFFF to lock forever.
     */
    'lockRoyalties(uint256,uint256)'(
      nftId: BigNumberish,
      lockUntil: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
     */
    makeAddressOfJointAccount(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Generate a unique address identifying a list of owners and shares. It may be used to predict the address of a Joint Account and receive payments even before calling the function createJointAccount.
     */
    'makeAddressOfJointAccount(address[],uint256[])'(
      owners: string[],
      fractions: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    makeOffer(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create an offer to sell a type of NFTs for a price per unit. All the NFTs of this type owned by the caller will be for sale. To cancel, call again with a price of 0.
     */
    'makeOffer(uint256,uint256)'(
      nftId: BigNumberish,
      price: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
     */
    takeOffer(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      price: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Accept an offer, paying the price per unit for an amount of NFTs. The offer must have been created beforehand by makeOffer. The same authorization as safeTransferFrom apply to the buyer (sender or approved operator)..
     */
    'takeOffer(address,address,uint256,uint256,uint256)'(
      buyer: string,
      seller: string,
      nftId: BigNumberish,
      price: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
     */
    updateChildChainManager(
      newChildChainManagerProxy: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Change the ChainManager, which can deposit currency into any account. Only the current ChainManager is allowed to change the ChainManager.
     */
    'updateChildChainManager(address)'(
      newChildChainManagerProxy: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
     */
    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraw currency from a user account in this contract to Ethereum. This is implemented by moving tokens from the user account to the bridge account. Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
