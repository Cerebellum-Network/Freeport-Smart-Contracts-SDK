/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import { Listener, Provider } from '@ethersproject/providers';
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export interface CollectionInterface extends utils.Interface {
  functions: {
    'COLLECTION_MANAGER_ROLE()': FunctionFragment;
    'DEFAULT_ADMIN_ROLE()': FunctionFragment;
    'META_TX_FORWARDER()': FunctionFragment;
    'TRANSFER_OPERATOR()': FunctionFragment;
    'anonymAttachToNFT(uint256,bytes)': FunctionFragment;
    'balanceOf(address,uint256)': FunctionFragment;
    'balanceOfBatch(address[],uint256[])': FunctionFragment;
    'contractURI()': FunctionFragment;
    'freeport()': FunctionFragment;
    'getGlobalNftId(uint32)': FunctionFragment;
    'getRoleAdmin(bytes32)': FunctionFragment;
    'getRoyalties()': FunctionFragment;
    'getRoyaltiesForBeneficiary(address)': FunctionFragment;
    'grantRole(bytes32,address)': FunctionFragment;
    'hasRole(bytes32,address)': FunctionFragment;
    'idCounter()': FunctionFragment;
    'isTrustedForwarder(address)': FunctionFragment;
    'issue(uint64,bytes)': FunctionFragment;
    'issueOnBehalfOf(address,uint64,bytes)': FunctionFragment;
    'minterAttachToNFT(uint256,bytes)': FunctionFragment;
    'name()': FunctionFragment;
    'nftAttachment()': FunctionFragment;
    'renounceRole(bytes32,address)': FunctionFragment;
    'revokeRole(bytes32,address)': FunctionFragment;
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)': FunctionFragment;
    'safeTransferFrom(address,address,uint256,uint256,bytes)': FunctionFragment;
    'setApprovalForAll(address,bool)': FunctionFragment;
    'setURI(string)': FunctionFragment;
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)': FunctionFragment;
    'transferFrom(address,address,uint256,uint256)': FunctionFragment;
    'upgradeTo(address)': FunctionFragment;
    'upgradeToAndCall(address,bytes)': FunctionFragment;
    'initialize(address,address,string,string,string,address,address,address,address)': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'isApprovedForAll(address,address)': FunctionFragment;
    'uri(uint256)': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'COLLECTION_MANAGER_ROLE',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'META_TX_FORWARDER',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'TRANSFER_OPERATOR',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'anonymAttachToNFT',
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOf',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOfBatch',
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: 'contractURI',
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: 'freeport', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getGlobalNftId',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoleAdmin',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoyalties',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoyaltiesForBeneficiary',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'grantRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'hasRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(functionFragment: 'idCounter', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'isTrustedForwarder',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'issue',
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'issueOnBehalfOf',
    values: [string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'minterAttachToNFT',
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'nftAttachment',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'renounceRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'revokeRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'safeBatchTransferFrom',
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'safeTransferFrom',
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'setApprovalForAll',
    values: [string, boolean]
  ): string;
  encodeFunctionData(functionFragment: 'setURI', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'setupRoyaltyConfiguration',
    values: [
      string,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'transferFrom',
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'upgradeTo', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'upgradeToAndCall',
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [
      string,
      string,
      string,
      string,
      string,
      string,
      string,
      string,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'isApprovedForAll',
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: 'uri', values: [BigNumberish]): string;

  decodeFunctionResult(
    functionFragment: 'COLLECTION_MANAGER_ROLE',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'META_TX_FORWARDER',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'TRANSFER_OPERATOR',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'anonymAttachToNFT',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'balanceOfBatch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'contractURI',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'freeport', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getGlobalNftId',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoleAdmin',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoyalties',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoyaltiesForBeneficiary',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'grantRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'idCounter', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'isTrustedForwarder',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'issue', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'issueOnBehalfOf',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'minterAttachToNFT',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'nftAttachment',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'renounceRole',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'revokeRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'safeBatchTransferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'safeTransferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setApprovalForAll',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'setURI', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'setupRoyaltyConfiguration',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'transferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'upgradeTo', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'upgradeToAndCall',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isApprovedForAll',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'uri', data: BytesLike): Result;

  events: {
    'AdminChanged(address,address)': EventFragment;
    'ApprovalForAll(address,address,bool)': EventFragment;
    'BeaconUpgraded(address)': EventFragment;
    'RoleAdminChanged(bytes32,bytes32,bytes32)': EventFragment;
    'RoleGranted(bytes32,address,address)': EventFragment;
    'RoleRevoked(bytes32,address,address)': EventFragment;
    'TransferBatch(address,address,address,uint256[],uint256[])': EventFragment;
    'TransferSingle(address,address,address,uint256,uint256)': EventFragment;
    'URI(string,uint256)': EventFragment;
    'Upgraded(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BeaconUpgraded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleAdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleGranted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleRevoked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferBatch'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferSingle'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'URI'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Upgraded'): EventFragment;
}

export type AdminChangedEvent = TypedEvent<
  [string, string],
  { previousAdmin: string; newAdmin: string }
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export type ApprovalForAllEvent = TypedEvent<
  [string, string, boolean],
  { account: string; operator: string; approved: boolean }
>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export type BeaconUpgradedEvent = TypedEvent<[string], { beacon: string }>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  { role: string; previousAdminRole: string; newAdminRole: string }
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export type TransferBatchEvent = TypedEvent<
  [string, string, string, BigNumber[], BigNumber[]],
  {
    operator: string;
    from: string;
    to: string;
    ids: BigNumber[];
    values: BigNumber[];
  }
>;

export type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;

export type TransferSingleEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    operator: string;
    from: string;
    to: string;
    id: BigNumber;
    value: BigNumber;
  }
>;

export type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;

export type URIEvent = TypedEvent<
  [string, BigNumber],
  { value: string; id: BigNumber }
>;

export type URIEventFilter = TypedEventFilter<URIEvent>;

export type UpgradedEvent = TypedEvent<[string], { implementation: string }>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface Collection extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CollectionInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    COLLECTION_MANAGER_ROLE(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    'COLLECTION_MANAGER_ROLE()'(overrides?: CallOverrides): Promise<[string]>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<[string]>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<[string]>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<[string]>;

    TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<[string]>;

    'TRANSFER_OPERATOR()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    anonymAttachToNFT(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    'anonymAttachToNFT(uint256,bytes)'(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    contractURI(overrides?: CallOverrides): Promise<[string]>;

    'contractURI()'(overrides?: CallOverrides): Promise<[string]>;

    freeport(overrides?: CallOverrides): Promise<[string]>;

    'freeport()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    getRoyalties(overrides?: CallOverrides): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    'getRoyalties()'(overrides?: CallOverrides): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(address)'(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * A counter of NFT types. This is used to generate unique NFT IDs.
     */
    idCounter(overrides?: CallOverrides): Promise<[number]>;

    /**
     * A counter of NFT types. This is used to generate unique NFT IDs.
     */
    'idCounter()'(overrides?: CallOverrides): Promise<[number]>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    issue(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    'issue(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
     */
    issueOnBehalfOf(
      minter: string,
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
     */
    'issueOnBehalfOf(address,uint64,bytes)'(
      minter: string,
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    minterAttachToNFT(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    'minterAttachToNFT(uint256,bytes)'(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string]>;

    'name()'(overrides?: CallOverrides): Promise<[string]>;

    nftAttachment(overrides?: CallOverrides): Promise<[string]>;

    'nftAttachment()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setURI(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'setURI(string)'(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    setupRoyaltyConfiguration(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    initialize(
      admin: string,
      manager: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      _marketplace: string,
      _auction: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'initialize(address,address,string,string,string,address,address,address,address)'(
      admin: string,
      manager: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      _marketplace: string,
      _auction: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * See {IERC165-supportsInterface}.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * URI override for OpenSea traits compatibility.
     */
    uri(nftId: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    /**
     * URI override for OpenSea traits compatibility.
     */
    'uri(uint256)'(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;
  };

  /**
   * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
   */
  COLLECTION_MANAGER_ROLE(overrides?: CallOverrides): Promise<string>;

  /**
   * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
   */
  'COLLECTION_MANAGER_ROLE()'(overrides?: CallOverrides): Promise<string>;

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

  META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

  'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

  TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<string>;

  'TRANSFER_OPERATOR()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id.
   */
  anonymAttachToNFT(
    nftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id.
   */
  'anonymAttachToNFT(uint256,bytes)'(
    nftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
   */
  balanceOf(
    account: string,
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
   */
  'balanceOf(address,uint256)'(
    account: string,
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
   */
  balanceOfBatch(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
   */
  'balanceOfBatch(address[],uint256[])'(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  contractURI(overrides?: CallOverrides): Promise<string>;

  'contractURI()'(overrides?: CallOverrides): Promise<string>;

  freeport(overrides?: CallOverrides): Promise<string>;

  'freeport()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Calculate the global ID of an NFT type, identifying its inner nft id.
   */
  getGlobalNftId(
    innerNftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Calculate the global ID of an NFT type, identifying its inner nft id.
   */
  'getGlobalNftId(uint32)'(
    innerNftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  'getRoleAdmin(bytes32)'(
    role: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Return the current configuration of royalties for all NFTs of the collection.
   */
  getRoyalties(overrides?: CallOverrides): Promise<
    [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
      primaryRoyaltyAccount: string;
      primaryRoyaltyCut: BigNumber;
      primaryRoyaltyMinimum: BigNumber;
      secondaryRoyaltyAccount: string;
      secondaryRoyaltyCut: BigNumber;
      secondaryRoyaltyMinimum: BigNumber;
    }
  >;

  /**
   * Return the current configuration of royalties for all NFTs of the collection.
   */
  'getRoyalties()'(overrides?: CallOverrides): Promise<
    [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
      primaryRoyaltyAccount: string;
      primaryRoyaltyCut: BigNumber;
      primaryRoyaltyMinimum: BigNumber;
      secondaryRoyaltyAccount: string;
      secondaryRoyaltyCut: BigNumber;
      secondaryRoyaltyMinimum: BigNumber;
    }
  >;

  /**
   * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
   */
  getRoyaltiesForBeneficiary(
    beneficiary: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      primaryCut: BigNumber;
      primaryMinimum: BigNumber;
      secondaryCut: BigNumber;
      secondaryMinimum: BigNumber;
    }
  >;

  /**
   * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
   */
  'getRoyaltiesForBeneficiary(address)'(
    beneficiary: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      primaryCut: BigNumber;
      primaryMinimum: BigNumber;
      secondaryCut: BigNumber;
      secondaryMinimum: BigNumber;
    }
  >;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  grantRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'grantRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  hasRole(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  'hasRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * A counter of NFT types. This is used to generate unique NFT IDs.
   */
  idCounter(overrides?: CallOverrides): Promise<number>;

  /**
   * A counter of NFT types. This is used to generate unique NFT IDs.
   */
  'idCounter()'(overrides?: CallOverrides): Promise<number>;

  isTrustedForwarder(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  'isTrustedForwarder(address)'(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
   */
  issue(
    supply: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
   */
  'issue(uint64,bytes)'(
    supply: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
   */
  issueOnBehalfOf(
    minter: string,
    supply: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
   */
  'issueOnBehalfOf(address,uint64,bytes)'(
    minter: string,
    supply: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
   */
  minterAttachToNFT(
    nftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
   */
  'minterAttachToNFT(uint256,bytes)'(
    nftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  'name()'(overrides?: CallOverrides): Promise<string>;

  nftAttachment(overrides?: CallOverrides): Promise<string>;

  'nftAttachment()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  renounceRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  'renounceRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  revokeRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'revokeRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeBatchTransferFrom}.
   */
  safeBatchTransferFrom(
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeBatchTransferFrom}.
   */
  'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeTransferFrom}.
   */
  safeTransferFrom(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeTransferFrom}.
   */
  'safeTransferFrom(address,address,uint256,uint256,bytes)'(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-setApprovalForAll}.
   */
  setApprovalForAll(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-setApprovalForAll}.
   */
  'setApprovalForAll(address,bool)'(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setURI(
    newuri: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'setURI(string)'(
    newuri: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
   */
  setupRoyaltyConfiguration(
    primaryRoyaltyAccount: string,
    primaryRoyaltyCut: BigNumberish,
    primaryRoyaltyMinimum: BigNumberish,
    secondaryRoyaltyAccount: string,
    secondaryRoyaltyCut: BigNumberish,
    secondaryRoyaltyMinimum: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
   */
  'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
    primaryRoyaltyAccount: string,
    primaryRoyaltyCut: BigNumberish,
    primaryRoyaltyMinimum: BigNumberish,
    secondaryRoyaltyAccount: string,
    secondaryRoyaltyCut: BigNumberish,
    secondaryRoyaltyMinimum: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
   */
  transferFrom(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
   */
  'transferFrom(address,address,uint256,uint256)'(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'upgradeTo(address)'(
    newImplementation: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'upgradeToAndCall(address,bytes)'(
    newImplementation: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  initialize(
    admin: string,
    manager: string,
    _name: string,
    _uri: string,
    __contractURI: string,
    _freeport: string,
    _nftAttachment: string,
    _marketplace: string,
    _auction: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'initialize(address,address,string,string,string,address,address,address,address)'(
    admin: string,
    manager: string,
    _name: string,
    _uri: string,
    __contractURI: string,
    _freeport: string,
    _nftAttachment: string,
    _marketplace: string,
    _auction: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC165-supportsInterface}.
   */
  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * See {IERC165-supportsInterface}.
   */
  'supportsInterface(bytes4)'(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isApprovedForAll(
    account: string,
    operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  'isApprovedForAll(address,address)'(
    account: string,
    operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * URI override for OpenSea traits compatibility.
   */
  uri(nftId: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * URI override for OpenSea traits compatibility.
   */
  'uri(uint256)'(
    nftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  callStatic: {
    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    COLLECTION_MANAGER_ROLE(overrides?: CallOverrides): Promise<string>;

    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    'COLLECTION_MANAGER_ROLE()'(overrides?: CallOverrides): Promise<string>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

    TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<string>;

    'TRANSFER_OPERATOR()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    anonymAttachToNFT(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    'anonymAttachToNFT(uint256,bytes)'(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    contractURI(overrides?: CallOverrides): Promise<string>;

    'contractURI()'(overrides?: CallOverrides): Promise<string>;

    freeport(overrides?: CallOverrides): Promise<string>;

    'freeport()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    getRoyalties(overrides?: CallOverrides): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    'getRoyalties()'(overrides?: CallOverrides): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(address)'(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * A counter of NFT types. This is used to generate unique NFT IDs.
     */
    idCounter(overrides?: CallOverrides): Promise<number>;

    /**
     * A counter of NFT types. This is used to generate unique NFT IDs.
     */
    'idCounter()'(overrides?: CallOverrides): Promise<number>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    issue(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    'issue(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
     */
    issueOnBehalfOf(
      minter: string,
      supply: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
     */
    'issueOnBehalfOf(address,uint64,bytes)'(
      minter: string,
      supply: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    minterAttachToNFT(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    'minterAttachToNFT(uint256,bytes)'(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    name(overrides?: CallOverrides): Promise<string>;

    'name()'(overrides?: CallOverrides): Promise<string>;

    nftAttachment(overrides?: CallOverrides): Promise<string>;

    'nftAttachment()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setURI(newuri: string, overrides?: CallOverrides): Promise<void>;

    'setURI(string)'(newuri: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    setupRoyaltyConfiguration(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      newImplementation: string,
      overrides?: CallOverrides
    ): Promise<void>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(
      admin: string,
      manager: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      _marketplace: string,
      _auction: string,
      overrides?: CallOverrides
    ): Promise<void>;

    'initialize(address,address,string,string,string,address,address,address,address)'(
      admin: string,
      manager: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      _marketplace: string,
      _auction: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC165-supportsInterface}.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * URI override for OpenSea traits compatibility.
     */
    uri(nftId: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * URI override for OpenSea traits compatibility.
     */
    'uri(uint256)'(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;
  };

  filters: {
    'AdminChanged(address,address)'(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    'ApprovalForAll(address,address,bool)'(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter;

    'BeaconUpgraded(address)'(
      beacon?: string | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(beacon?: string | null): BeaconUpgradedEventFilter;

    'RoleAdminChanged(bytes32,bytes32,bytes32)'(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;

    'RoleGranted(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;

    'RoleRevoked(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;

    'TransferBatch(address,address,address,uint256[],uint256[])'(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;
    TransferBatch(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;

    'TransferSingle(address,address,address,uint256,uint256)'(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;
    TransferSingle(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;

    'URI(string,uint256)'(
      value?: null,
      id?: BigNumberish | null
    ): URIEventFilter;
    URI(value?: null, id?: BigNumberish | null): URIEventFilter;

    'Upgraded(address)'(implementation?: string | null): UpgradedEventFilter;
    Upgraded(implementation?: string | null): UpgradedEventFilter;
  };

  estimateGas: {
    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    COLLECTION_MANAGER_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    'COLLECTION_MANAGER_ROLE()'(overrides?: CallOverrides): Promise<BigNumber>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<BigNumber>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<BigNumber>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<BigNumber>;

    TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<BigNumber>;

    'TRANSFER_OPERATOR()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    anonymAttachToNFT(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    'anonymAttachToNFT(uint256,bytes)'(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contractURI(overrides?: CallOverrides): Promise<BigNumber>;

    'contractURI()'(overrides?: CallOverrides): Promise<BigNumber>;

    freeport(overrides?: CallOverrides): Promise<BigNumber>;

    'freeport()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    getRoyalties(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    'getRoyalties()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(address)'(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * A counter of NFT types. This is used to generate unique NFT IDs.
     */
    idCounter(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * A counter of NFT types. This is used to generate unique NFT IDs.
     */
    'idCounter()'(overrides?: CallOverrides): Promise<BigNumber>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    issue(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    'issue(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
     */
    issueOnBehalfOf(
      minter: string,
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
     */
    'issueOnBehalfOf(address,uint64,bytes)'(
      minter: string,
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    minterAttachToNFT(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    'minterAttachToNFT(uint256,bytes)'(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    'name()'(overrides?: CallOverrides): Promise<BigNumber>;

    nftAttachment(overrides?: CallOverrides): Promise<BigNumber>;

    'nftAttachment()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setURI(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'setURI(string)'(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    setupRoyaltyConfiguration(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    initialize(
      admin: string,
      manager: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      _marketplace: string,
      _auction: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'initialize(address,address,string,string,string,address,address,address,address)'(
      admin: string,
      manager: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      _marketplace: string,
      _auction: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC165-supportsInterface}.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * URI override for OpenSea traits compatibility.
     */
    uri(nftId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * URI override for OpenSea traits compatibility.
     */
    'uri(uint256)'(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    COLLECTION_MANAGER_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    'COLLECTION_MANAGER_ROLE()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'DEFAULT_ADMIN_ROLE()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'META_TX_FORWARDER()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    TRANSFER_OPERATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'TRANSFER_OPERATOR()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    anonymAttachToNFT(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    'anonymAttachToNFT(uint256,bytes)'(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    contractURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'contractURI()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    freeport(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'freeport()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    getRoyalties(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    'getRoyalties()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(address)'(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * A counter of NFT types. This is used to generate unique NFT IDs.
     */
    idCounter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * A counter of NFT types. This is used to generate unique NFT IDs.
     */
    'idCounter()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    issue(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Issue a supply of NFTs of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply.
     */
    'issue(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
     */
    issueOnBehalfOf(
      minter: string,
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Issue a supply of NFTs of a new type on behalf of minter, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the entire supply. Only for collection manager role.
     */
    'issueOnBehalfOf(address,uint64,bytes)'(
      minter: string,
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    minterAttachToNFT(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    'minterAttachToNFT(uint256,bytes)'(
      nftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'name()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nftAttachment(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'nftAttachment()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setURI(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'setURI(string)'(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    setupRoyaltyConfiguration(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      admin: string,
      manager: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      _marketplace: string,
      _auction: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'initialize(address,address,string,string,string,address,address,address,address)'(
      admin: string,
      manager: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      _marketplace: string,
      _auction: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC165-supportsInterface}.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * URI override for OpenSea traits compatibility.
     */
    uri(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * URI override for OpenSea traits compatibility.
     */
    'uri(uint256)'(
      nftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
