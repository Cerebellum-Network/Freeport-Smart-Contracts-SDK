/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import { Listener, Provider } from '@ethersproject/providers';
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export interface CollectionInterface extends utils.Interface {
  functions: {
    'COLLECTION_MANAGER_ROLE()': FunctionFragment;
    'DEFAULT_ADMIN_ROLE()': FunctionFragment;
    'META_TX_FORWARDER()': FunctionFragment;
    'balanceOf(address,uint256)': FunctionFragment;
    'balanceOfBatch(address[],uint256[])': FunctionFragment;
    'freeport()': FunctionFragment;
    'getRoleAdmin(bytes32)': FunctionFragment;
    'grantRole(bytes32,address)': FunctionFragment;
    'hasRole(bytes32,address)': FunctionFragment;
    'idCounter()': FunctionFragment;
    'isApprovedForAll(address,address)': FunctionFragment;
    'isTrustedForwarder(address)': FunctionFragment;
    'name()': FunctionFragment;
    'nftAttachment()': FunctionFragment;
    'renounceRole(bytes32,address)': FunctionFragment;
    'revokeRole(bytes32,address)': FunctionFragment;
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)': FunctionFragment;
    'safeTransferFrom(address,address,uint256,uint256,bytes)': FunctionFragment;
    'setApprovalForAll(address,bool)': FunctionFragment;
    'setURI(string)': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'transferFrom(address,address,uint256,uint256)': FunctionFragment;
    'upgradeTo(address)': FunctionFragment;
    'upgradeToAndCall(address,bytes)': FunctionFragment;
    'uri(uint256)': FunctionFragment;
    'initialize(address,address,string,string,string,address,address)': FunctionFragment;
    'contractURI()': FunctionFragment;
    'issueNft(uint64,bytes)': FunctionFragment;
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)': FunctionFragment;
    'getRoyalties()': FunctionFragment;
    'getRoyaltiesForBeneficiary(address)': FunctionFragment;
    'minterAttachToNFT(uint32,bytes)': FunctionFragment;
    'ownerAttachToNFT(uint32,bytes)': FunctionFragment;
    'anonymAttachToNFT(uint32,bytes)': FunctionFragment;
    'getGlobalNftId(uint32)': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'COLLECTION_MANAGER_ROLE',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'META_TX_FORWARDER',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOf',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'balanceOfBatch',
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(functionFragment: 'freeport', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'getRoleAdmin',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'grantRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'hasRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(functionFragment: 'idCounter', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'isApprovedForAll',
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'isTrustedForwarder',
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'nftAttachment',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'renounceRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'revokeRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'safeBatchTransferFrom',
    values: [string, string, BigNumberish[], BigNumberish[], BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'safeTransferFrom',
    values: [string, string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'setApprovalForAll',
    values: [string, boolean]
  ): string;
  encodeFunctionData(functionFragment: 'setURI', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'transferFrom',
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'upgradeTo', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'upgradeToAndCall',
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'uri', values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [string, string, string, string, string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'contractURI',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'issueNft',
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'setupRoyaltyConfiguration',
    values: [
      string,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoyalties',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoyaltiesForBeneficiary',
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: 'minterAttachToNFT',
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'ownerAttachToNFT',
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'anonymAttachToNFT',
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'getGlobalNftId',
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: 'COLLECTION_MANAGER_ROLE',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'META_TX_FORWARDER',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'balanceOfBatch',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'freeport', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getRoleAdmin',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'grantRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'idCounter', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'isApprovedForAll',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isTrustedForwarder',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'nftAttachment',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'renounceRole',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'revokeRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'safeBatchTransferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'safeTransferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setApprovalForAll',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'setURI', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'transferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'upgradeTo', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'upgradeToAndCall',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'uri', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'contractURI',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'issueNft', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'setupRoyaltyConfiguration',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoyalties',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoyaltiesForBeneficiary',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'minterAttachToNFT',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'ownerAttachToNFT',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'anonymAttachToNFT',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getGlobalNftId',
    data: BytesLike
  ): Result;

  events: {
    'AdminChanged(address,address)': EventFragment;
    'ApprovalForAll(address,address,bool)': EventFragment;
    'BeaconUpgraded(address)': EventFragment;
    'RoleAdminChanged(bytes32,bytes32,bytes32)': EventFragment;
    'RoleGranted(bytes32,address,address)': EventFragment;
    'RoleRevoked(bytes32,address,address)': EventFragment;
    'TransferBatch(address,address,address,uint256[],uint256[])': EventFragment;
    'TransferSingle(address,address,address,uint256,uint256)': EventFragment;
    'URI(string,uint256)': EventFragment;
    'Upgraded(address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'ApprovalForAll'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'BeaconUpgraded'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleAdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleGranted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleRevoked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferBatch'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TransferSingle'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'URI'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Upgraded'): EventFragment;
}

export type AdminChangedEvent = TypedEvent<
  [string, string],
  { previousAdmin: string; newAdmin: string }
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export type ApprovalForAllEvent = TypedEvent<
  [string, string, boolean],
  { account: string; operator: string; approved: boolean }
>;

export type ApprovalForAllEventFilter = TypedEventFilter<ApprovalForAllEvent>;

export type BeaconUpgradedEvent = TypedEvent<[string], { beacon: string }>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  { role: string; previousAdminRole: string; newAdminRole: string }
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export type TransferBatchEvent = TypedEvent<
  [string, string, string, BigNumber[], BigNumber[]],
  {
    operator: string;
    from: string;
    to: string;
    ids: BigNumber[];
    values: BigNumber[];
  }
>;

export type TransferBatchEventFilter = TypedEventFilter<TransferBatchEvent>;

export type TransferSingleEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  {
    operator: string;
    from: string;
    to: string;
    id: BigNumber;
    value: BigNumber;
  }
>;

export type TransferSingleEventFilter = TypedEventFilter<TransferSingleEvent>;

export type URIEvent = TypedEvent<
  [string, BigNumber],
  { value: string; id: BigNumber }
>;

export type URIEventFilter = TypedEventFilter<URIEvent>;

export type UpgradedEvent = TypedEvent<[string], { implementation: string }>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface Collection extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CollectionInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    COLLECTION_MANAGER_ROLE(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    'COLLECTION_MANAGER_ROLE()'(overrides?: CallOverrides): Promise<[string]>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<[string]>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<[string]>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    freeport(overrides?: CallOverrides): Promise<[string]>;

    'freeport()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * A counter of NFT types issued. This is used to generate unique NFT IDs.
     */
    idCounter(overrides?: CallOverrides): Promise<[number]>;

    /**
     * A counter of NFT types issued. This is used to generate unique NFT IDs.
     */
    'idCounter()'(overrides?: CallOverrides): Promise<[number]>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    name(overrides?: CallOverrides): Promise<[string]>;

    'name()'(overrides?: CallOverrides): Promise<[string]>;

    nftAttachment(overrides?: CallOverrides): Promise<[string]>;

    'nftAttachment()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setURI(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'setURI(string)'(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    initialize(
      admin: string,
      minter: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'initialize(address,address,string,string,string,address,address)'(
      admin: string,
      minter: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    contractURI(overrides?: CallOverrides): Promise<[string]>;

    'contractURI()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
     */
    issueNft(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
     */
    'issueNft(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    setupRoyaltyConfiguration(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    getRoyalties(overrides?: CallOverrides): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    'getRoyalties()'(overrides?: CallOverrides): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(address)'(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    minterAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    'minterAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
     */
    ownerAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
     */
    'ownerAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    anonymAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    'anonymAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;
  };

  /**
   * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
   */
  COLLECTION_MANAGER_ROLE(overrides?: CallOverrides): Promise<string>;

  /**
   * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
   */
  'COLLECTION_MANAGER_ROLE()'(overrides?: CallOverrides): Promise<string>;

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

  META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

  'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

  /**
   * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
   */
  balanceOf(
    account: string,
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
   */
  'balanceOf(address,uint256)'(
    account: string,
    id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
   */
  balanceOfBatch(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
   */
  'balanceOfBatch(address[],uint256[])'(
    accounts: string[],
    ids: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  freeport(overrides?: CallOverrides): Promise<string>;

  'freeport()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  'getRoleAdmin(bytes32)'(
    role: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  grantRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'grantRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  hasRole(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  'hasRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * A counter of NFT types issued. This is used to generate unique NFT IDs.
   */
  idCounter(overrides?: CallOverrides): Promise<number>;

  /**
   * A counter of NFT types issued. This is used to generate unique NFT IDs.
   */
  'idCounter()'(overrides?: CallOverrides): Promise<number>;

  /**
   * See {IERC1155-isApprovedForAll}.
   */
  isApprovedForAll(
    account: string,
    operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * See {IERC1155-isApprovedForAll}.
   */
  'isApprovedForAll(address,address)'(
    account: string,
    operator: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTrustedForwarder(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  'isTrustedForwarder(address)'(
    forwarder: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  name(overrides?: CallOverrides): Promise<string>;

  'name()'(overrides?: CallOverrides): Promise<string>;

  nftAttachment(overrides?: CallOverrides): Promise<string>;

  'nftAttachment()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  renounceRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  'renounceRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  revokeRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'revokeRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeBatchTransferFrom}.
   */
  safeBatchTransferFrom(
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeBatchTransferFrom}.
   */
  'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
    from: string,
    to: string,
    ids: BigNumberish[],
    amounts: BigNumberish[],
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeTransferFrom}.
   */
  safeTransferFrom(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-safeTransferFrom}.
   */
  'safeTransferFrom(address,address,uint256,uint256,bytes)'(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-setApprovalForAll}.
   */
  setApprovalForAll(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155-setApprovalForAll}.
   */
  'setApprovalForAll(address,bool)'(
    operator: string,
    approved: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setURI(
    newuri: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'setURI(string)'(
    newuri: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
   */
  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
   */
  'supportsInterface(bytes4)'(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
   */
  transferFrom(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
   */
  'transferFrom(address,address,uint256,uint256)'(
    from: string,
    to: string,
    id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'upgradeTo(address)'(
    newImplementation: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'upgradeToAndCall(address,bytes)'(
    newImplementation: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
   */
  uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
   */
  'uri(uint256)'(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  initialize(
    admin: string,
    minter: string,
    _name: string,
    _uri: string,
    __contractURI: string,
    _freeport: string,
    _nftAttachment: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'initialize(address,address,string,string,string,address,address)'(
    admin: string,
    minter: string,
    _name: string,
    _uri: string,
    __contractURI: string,
    _freeport: string,
    _nftAttachment: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  contractURI(overrides?: CallOverrides): Promise<string>;

  'contractURI()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
   */
  issueNft(
    supply: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
   */
  'issueNft(uint64,bytes)'(
    supply: BigNumberish,
    data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
   */
  setupRoyaltyConfiguration(
    primaryRoyaltyAccount: string,
    primaryRoyaltyCut: BigNumberish,
    primaryRoyaltyMinimum: BigNumberish,
    secondaryRoyaltyAccount: string,
    secondaryRoyaltyCut: BigNumberish,
    secondaryRoyaltyMinimum: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
   */
  'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
    primaryRoyaltyAccount: string,
    primaryRoyaltyCut: BigNumberish,
    primaryRoyaltyMinimum: BigNumberish,
    secondaryRoyaltyAccount: string,
    secondaryRoyaltyCut: BigNumberish,
    secondaryRoyaltyMinimum: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Return the current configuration of royalties for all NFTs of the collection.
   */
  getRoyalties(overrides?: CallOverrides): Promise<
    [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
      primaryRoyaltyAccount: string;
      primaryRoyaltyCut: BigNumber;
      primaryRoyaltyMinimum: BigNumber;
      secondaryRoyaltyAccount: string;
      secondaryRoyaltyCut: BigNumber;
      secondaryRoyaltyMinimum: BigNumber;
    }
  >;

  /**
   * Return the current configuration of royalties for all NFTs of the collection.
   */
  'getRoyalties()'(overrides?: CallOverrides): Promise<
    [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
      primaryRoyaltyAccount: string;
      primaryRoyaltyCut: BigNumber;
      primaryRoyaltyMinimum: BigNumber;
      secondaryRoyaltyAccount: string;
      secondaryRoyaltyCut: BigNumber;
      secondaryRoyaltyMinimum: BigNumber;
    }
  >;

  /**
   * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
   */
  getRoyaltiesForBeneficiary(
    beneficiary: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      primaryCut: BigNumber;
      primaryMinimum: BigNumber;
      secondaryCut: BigNumber;
      secondaryMinimum: BigNumber;
    }
  >;

  /**
   * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
   */
  'getRoyaltiesForBeneficiary(address)'(
    beneficiary: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber] & {
      primaryCut: BigNumber;
      primaryMinimum: BigNumber;
      secondaryCut: BigNumber;
      secondaryMinimum: BigNumber;
    }
  >;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
   */
  minterAttachToNFT(
    innerNftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
   */
  'minterAttachToNFT(uint32,bytes)'(
    innerNftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
   */
  ownerAttachToNFT(
    innerNftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
   */
  'ownerAttachToNFT(uint32,bytes)'(
    innerNftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id.
   */
  anonymAttachToNFT(
    innerNftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Attach data `attachment` to the collection NFT with specific inner NFT id.
   */
  'anonymAttachToNFT(uint32,bytes)'(
    innerNftId: BigNumberish,
    attachment: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Calculate the global ID of an NFT type, identifying its inner nft id.
   */
  getGlobalNftId(
    innerNftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Calculate the global ID of an NFT type, identifying its inner nft id.
   */
  'getGlobalNftId(uint32)'(
    innerNftId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    COLLECTION_MANAGER_ROLE(overrides?: CallOverrides): Promise<string>;

    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    'COLLECTION_MANAGER_ROLE()'(overrides?: CallOverrides): Promise<string>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<string>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<string>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    freeport(overrides?: CallOverrides): Promise<string>;

    'freeport()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * A counter of NFT types issued. This is used to generate unique NFT IDs.
     */
    idCounter(overrides?: CallOverrides): Promise<number>;

    /**
     * A counter of NFT types issued. This is used to generate unique NFT IDs.
     */
    'idCounter()'(overrides?: CallOverrides): Promise<number>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    name(overrides?: CallOverrides): Promise<string>;

    'name()'(overrides?: CallOverrides): Promise<string>;

    nftAttachment(overrides?: CallOverrides): Promise<string>;

    'nftAttachment()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    setURI(newuri: string, overrides?: CallOverrides): Promise<void>;

    'setURI(string)'(newuri: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeTo(
      newImplementation: string,
      overrides?: CallOverrides
    ): Promise<void>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    initialize(
      admin: string,
      minter: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      overrides?: CallOverrides
    ): Promise<void>;

    'initialize(address,address,string,string,string,address,address)'(
      admin: string,
      minter: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      overrides?: CallOverrides
    ): Promise<void>;

    contractURI(overrides?: CallOverrides): Promise<string>;

    'contractURI()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
     */
    issueNft(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
     */
    'issueNft(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    setupRoyaltyConfiguration(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    getRoyalties(overrides?: CallOverrides): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    'getRoyalties()'(overrides?: CallOverrides): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        primaryRoyaltyAccount: string;
        primaryRoyaltyCut: BigNumber;
        primaryRoyaltyMinimum: BigNumber;
        secondaryRoyaltyAccount: string;
        secondaryRoyaltyCut: BigNumber;
        secondaryRoyaltyMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(address)'(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        primaryCut: BigNumber;
        primaryMinimum: BigNumber;
        secondaryCut: BigNumber;
        secondaryMinimum: BigNumber;
      }
    >;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    minterAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    'minterAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
     */
    ownerAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
     */
    'ownerAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    anonymAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    'anonymAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    'AdminChanged(address,address)'(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    'ApprovalForAll(address,address,bool)'(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter;
    ApprovalForAll(
      account?: string | null,
      operator?: string | null,
      approved?: null
    ): ApprovalForAllEventFilter;

    'BeaconUpgraded(address)'(
      beacon?: string | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(beacon?: string | null): BeaconUpgradedEventFilter;

    'RoleAdminChanged(bytes32,bytes32,bytes32)'(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;

    'RoleGranted(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;

    'RoleRevoked(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;

    'TransferBatch(address,address,address,uint256[],uint256[])'(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;
    TransferBatch(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      ids?: null,
      values?: null
    ): TransferBatchEventFilter;

    'TransferSingle(address,address,address,uint256,uint256)'(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;
    TransferSingle(
      operator?: string | null,
      from?: string | null,
      to?: string | null,
      id?: null,
      value?: null
    ): TransferSingleEventFilter;

    'URI(string,uint256)'(
      value?: null,
      id?: BigNumberish | null
    ): URIEventFilter;
    URI(value?: null, id?: BigNumberish | null): URIEventFilter;

    'Upgraded(address)'(implementation?: string | null): UpgradedEventFilter;
    Upgraded(implementation?: string | null): UpgradedEventFilter;
  };

  estimateGas: {
    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    COLLECTION_MANAGER_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    'COLLECTION_MANAGER_ROLE()'(overrides?: CallOverrides): Promise<BigNumber>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<BigNumber>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<BigNumber>;

    'META_TX_FORWARDER()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    freeport(overrides?: CallOverrides): Promise<BigNumber>;

    'freeport()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * A counter of NFT types issued. This is used to generate unique NFT IDs.
     */
    idCounter(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * A counter of NFT types issued. This is used to generate unique NFT IDs.
     */
    'idCounter()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    'name()'(overrides?: CallOverrides): Promise<BigNumber>;

    nftAttachment(overrides?: CallOverrides): Promise<BigNumber>;

    'nftAttachment()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setURI(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'setURI(string)'(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      admin: string,
      minter: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'initialize(address,address,string,string,string,address,address)'(
      admin: string,
      minter: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    contractURI(overrides?: CallOverrides): Promise<BigNumber>;

    'contractURI()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
     */
    issueNft(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
     */
    'issueNft(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    setupRoyaltyConfiguration(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    getRoyalties(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    'getRoyalties()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(address)'(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    minterAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    'minterAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
     */
    ownerAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
     */
    'ownerAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    anonymAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    'anonymAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    COLLECTION_MANAGER_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Collection manager role.  Used for configuring the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.
     */
    'COLLECTION_MANAGER_ROLE()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'DEFAULT_ADMIN_ROLE()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    META_TX_FORWARDER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'META_TX_FORWARDER()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    balanceOf(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.
     */
    'balanceOf(address,uint256)'(
      account: string,
      id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    balanceOfBatch(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.
     */
    'balanceOfBatch(address[],uint256[])'(
      accounts: string[],
      ids: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    freeport(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'freeport()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * A counter of NFT types issued. This is used to generate unique NFT IDs.
     */
    idCounter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * A counter of NFT types issued. This is used to generate unique NFT IDs.
     */
    'idCounter()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    isApprovedForAll(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-isApprovedForAll}.
     */
    'isApprovedForAll(address,address)'(
      account: string,
      operator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTrustedForwarder(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'isTrustedForwarder(address)'(
      forwarder: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'name()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nftAttachment(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'nftAttachment()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    safeBatchTransferFrom(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeBatchTransferFrom}.
     */
    'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)'(
      from: string,
      to: string,
      ids: BigNumberish[],
      amounts: BigNumberish[],
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    safeTransferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-safeTransferFrom}.
     */
    'safeTransferFrom(address,address,uint256,uint256,bytes)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    setApprovalForAll(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155-setApprovalForAll}.
     */
    'setApprovalForAll(address,bool)'(
      operator: string,
      approved: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setURI(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'setURI(string)'(
      newuri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.
     */
    'supportsInterface(bytes4)'(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    transferFrom(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * transferFrom performs a simple transfer, without calling the hooks  (no _beforeTokenTransfer and no onERC1155Received).
     */
    'transferFrom(address,address,uint256,uint256)'(
      from: string,
      to: string,
      id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'upgradeTo(address)'(
      newImplementation: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'upgradeToAndCall(address,bytes)'(
      newImplementation: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    uri(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC1155MetadataURI-uri}. This implementation returns the same URI for *all* token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the `\{id\}` substring with the actual token type ID.
     */
    'uri(uint256)'(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      admin: string,
      minter: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'initialize(address,address,string,string,string,address,address)'(
      admin: string,
      minter: string,
      _name: string,
      _uri: string,
      __contractURI: string,
      _freeport: string,
      _nftAttachment: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    contractURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'contractURI()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
     */
    issueNft(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Issue NFT of a new type, and return its ID. No more NFT of this type can be issued again. The caller will be recorded as the issuer and it will initially own the NFT.
     */
    'issueNft(uint64,bytes)'(
      supply: BigNumberish,
      data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    setupRoyaltyConfiguration(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.  Delegating to Freeport implementation.
     */
    'setupRoyaltyConfiguration(address,uint256,uint256,address,uint256,uint256)'(
      primaryRoyaltyAccount: string,
      primaryRoyaltyCut: BigNumberish,
      primaryRoyaltyMinimum: BigNumberish,
      secondaryRoyaltyAccount: string,
      secondaryRoyaltyCut: BigNumberish,
      secondaryRoyaltyMinimum: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    getRoyalties(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Return the current configuration of royalties for all NFTs of the collection.
     */
    'getRoyalties()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    getRoyaltiesForBeneficiary(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT. This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA, the shares of the royalties for this owner are returned.
     */
    'getRoyaltiesForBeneficiary(address)'(
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    minterAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as the minter of this NFT type. This only works for NFT IDs in the Freeport format.
     */
    'minterAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
     */
    ownerAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id, as a current owner of an NFT of this type. This works for NFTs in the ERC-1155 or Freeport standards.
     */
    'ownerAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    anonymAttachToNFT(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Attach data `attachment` to the collection NFT with specific inner NFT id.
     */
    'anonymAttachToNFT(uint32,bytes)'(
      innerNftId: BigNumberish,
      attachment: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    getGlobalNftId(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate the global ID of an NFT type, identifying its inner nft id.
     */
    'getGlobalNftId(uint32)'(
      innerNftId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
