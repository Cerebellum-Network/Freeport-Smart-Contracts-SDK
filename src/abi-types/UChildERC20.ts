/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import { Listener, Provider } from '@ethersproject/providers';
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export interface UChildERC20Interface extends utils.Interface {
  functions: {
    'APPROVE_WITH_AUTHORIZATION_TYPEHASH()': FunctionFragment;
    'CANCEL_AUTHORIZATION_TYPEHASH()': FunctionFragment;
    'DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()': FunctionFragment;
    'DEFAULT_ADMIN_ROLE()': FunctionFragment;
    'DEPOSITOR_ROLE()': FunctionFragment;
    'DOMAIN_SEPARATOR()': FunctionFragment;
    'EIP712_VERSION()': FunctionFragment;
    'INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()': FunctionFragment;
    'META_TRANSACTION_TYPEHASH()': FunctionFragment;
    'PERMIT_TYPEHASH()': FunctionFragment;
    'TRANSFER_WITH_AUTHORIZATION_TYPEHASH()': FunctionFragment;
    'WITHDRAW_WITH_AUTHORIZATION_TYPEHASH()': FunctionFragment;
    'allowance(address,address)': FunctionFragment;
    'approve(address,uint256)': FunctionFragment;
    'authorizationState(address,bytes32)': FunctionFragment;
    'balanceOf(address)': FunctionFragment;
    'decimals()': FunctionFragment;
    'decreaseAllowance(address,uint256)': FunctionFragment;
    'executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)': FunctionFragment;
    'getRoleAdmin(bytes32)': FunctionFragment;
    'getRoleMember(bytes32,uint256)': FunctionFragment;
    'getRoleMemberCount(bytes32)': FunctionFragment;
    'grantRole(bytes32,address)': FunctionFragment;
    'hasRole(bytes32,address)': FunctionFragment;
    'increaseAllowance(address,uint256)': FunctionFragment;
    'initialized()': FunctionFragment;
    'name()': FunctionFragment;
    'nonces(address)': FunctionFragment;
    'renounceRole(bytes32,address)': FunctionFragment;
    'revokeRole(bytes32,address)': FunctionFragment;
    'symbol()': FunctionFragment;
    'totalSupply()': FunctionFragment;
    'transfer(address,uint256)': FunctionFragment;
    'transferFrom(address,address,uint256)': FunctionFragment;
    'initialize(string,string,uint8,address)': FunctionFragment;
    'updateMetadata(string,string)': FunctionFragment;
    'deposit(address,bytes)': FunctionFragment;
    'withdraw(uint256)': FunctionFragment;
    'permit(address,address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'transferWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)': FunctionFragment;
    'approveWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)': FunctionFragment;
    'increaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)': FunctionFragment;
    'decreaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)': FunctionFragment;
    'withdrawWithAuthorization(address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)': FunctionFragment;
    'cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'APPROVE_WITH_AUTHORIZATION_TYPEHASH',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'CANCEL_AUTHORIZATION_TYPEHASH',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'DEPOSITOR_ROLE',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'DOMAIN_SEPARATOR',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'EIP712_VERSION',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'META_TRANSACTION_TYPEHASH',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'PERMIT_TYPEHASH',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'TRANSFER_WITH_AUTHORIZATION_TYPEHASH',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'WITHDRAW_WITH_AUTHORIZATION_TYPEHASH',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'allowance',
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'approve',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'authorizationState',
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'balanceOf', values: [string]): string;
  encodeFunctionData(functionFragment: 'decimals', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'decreaseAllowance',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'executeMetaTransaction',
    values: [string, BytesLike, BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoleAdmin',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoleMember',
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoleMemberCount',
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'grantRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'hasRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'increaseAllowance',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'initialized',
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: 'name', values?: undefined): string;
  encodeFunctionData(functionFragment: 'nonces', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'renounceRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'revokeRole',
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'totalSupply',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'transfer',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'transferFrom',
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [string, string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'updateMetadata',
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'permit',
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'transferWithAuthorization',
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'approveWithAuthorization',
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'increaseAllowanceWithAuthorization',
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'decreaseAllowanceWithAuthorization',
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'withdrawWithAuthorization',
    values: [
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'cancelAuthorization',
    values: [string, BytesLike, BigNumberish, BytesLike, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: 'APPROVE_WITH_AUTHORIZATION_TYPEHASH',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'CANCEL_AUTHORIZATION_TYPEHASH',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'DEPOSITOR_ROLE',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'DOMAIN_SEPARATOR',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'EIP712_VERSION',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'META_TRANSACTION_TYPEHASH',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'PERMIT_TYPEHASH',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'TRANSFER_WITH_AUTHORIZATION_TYPEHASH',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'WITHDRAW_WITH_AUTHORIZATION_TYPEHASH',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'allowance', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'approve', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'authorizationState',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'decimals', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'decreaseAllowance',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'executeMetaTransaction',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoleAdmin',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoleMember',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoleMemberCount',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'grantRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'increaseAllowance',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'initialized',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nonces', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'renounceRole',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'revokeRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'totalSupply',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'transfer', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'transferFrom',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'updateMetadata',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'permit', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'transferWithAuthorization',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'approveWithAuthorization',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'increaseAllowanceWithAuthorization',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'decreaseAllowanceWithAuthorization',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'withdrawWithAuthorization',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'cancelAuthorization',
    data: BytesLike
  ): Result;

  events: {
    'Approval(address,address,uint256)': EventFragment;
    'AuthorizationCanceled(address,bytes32)': EventFragment;
    'AuthorizationUsed(address,bytes32)': EventFragment;
    'MetaTransactionExecuted(address,address,bytes)': EventFragment;
    'RoleAdminChanged(bytes32,bytes32,bytes32)': EventFragment;
    'RoleGranted(bytes32,address,address)': EventFragment;
    'RoleRevoked(bytes32,address,address)': EventFragment;
    'Transfer(address,address,uint256)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'Approval'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'AuthorizationCanceled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'AuthorizationUsed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MetaTransactionExecuted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleAdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleGranted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleRevoked'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Transfer'): EventFragment;
}

export type ApprovalEvent = TypedEvent<
  [string, string, BigNumber],
  { owner: string; spender: string; value: BigNumber }
>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export type AuthorizationCanceledEvent = TypedEvent<
  [string, string],
  { authorizer: string; nonce: string }
>;

export type AuthorizationCanceledEventFilter =
  TypedEventFilter<AuthorizationCanceledEvent>;

export type AuthorizationUsedEvent = TypedEvent<
  [string, string],
  { authorizer: string; nonce: string }
>;

export type AuthorizationUsedEventFilter =
  TypedEventFilter<AuthorizationUsedEvent>;

export type MetaTransactionExecutedEvent = TypedEvent<
  [string, string, string],
  { userAddress: string; relayerAddress: string; functionSignature: string }
>;

export type MetaTransactionExecutedEventFilter =
  TypedEventFilter<MetaTransactionExecutedEvent>;

export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  { role: string; previousAdminRole: string; newAdminRole: string }
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  { role: string; account: string; sender: string }
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  { from: string; to: string; value: BigNumber }
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface UChildERC20 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: UChildERC20Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    APPROVE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<[string]>;

    'APPROVE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<[string]>;

    CANCEL_AUTHORIZATION_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    'CANCEL_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<[string]>;

    DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<[string]>;

    'DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<[string]>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<[string]>;

    DEPOSITOR_ROLE(overrides?: CallOverrides): Promise<[string]>;

    'DEPOSITOR_ROLE()'(overrides?: CallOverrides): Promise<[string]>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    'DOMAIN_SEPARATOR()'(overrides?: CallOverrides): Promise<[string]>;

    EIP712_VERSION(overrides?: CallOverrides): Promise<[string]>;

    'EIP712_VERSION()'(overrides?: CallOverrides): Promise<[string]>;

    INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<[string]>;

    'INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<[string]>;

    META_TRANSACTION_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    'META_TRANSACTION_TYPEHASH()'(overrides?: CallOverrides): Promise<[string]>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    'PERMIT_TYPEHASH()'(overrides?: CallOverrides): Promise<[string]>;

    TRANSFER_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<[string]>;

    'TRANSFER_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<[string]>;

    WITHDRAW_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<[string]>;

    'WITHDRAW_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * See {IERC20-allowance}.
     */
    allowance(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC20-allowance}.
     */
    'allowance(address,address)'(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
     */
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
     */
    'approve(address,uint256)'(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns the state of an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     */
    authorizationState(
      authorizer: string,
      nonce: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number]>;

    /**
     * Returns the state of an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     */
    'authorizationState(address,bytes32)'(
      authorizer: string,
      nonce: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number]>;

    /**
     * See {IERC20-balanceOf}.
     */
    balanceOf(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * See {IERC20-balanceOf}.
     */
    'balanceOf(address)'(
      account: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    decimals(overrides?: CallOverrides): Promise<[number]>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    'decimals()'(overrides?: CallOverrides): Promise<[number]>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    'decreaseAllowance(address,uint256)'(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    executeMetaTransaction(
      userAddress: string,
      functionSignature: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)'(
      userAddress: string,
      functionSignature: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    getRoleMember(
      role: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    'getRoleMember(bytes32,uint256)'(
      role: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    getRoleMemberCount(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    'getRoleMemberCount(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    'increaseAllowance(address,uint256)'(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    initialized(overrides?: CallOverrides): Promise<[boolean]>;

    'initialized()'(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Returns the name of the token.
     */
    name(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the name of the token.
     */
    'name()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Nonces for permit / meta-transactions
     * @param owner Token owner's address
     */
    nonces(owner: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Nonces for permit / meta-transactions
     * @param owner Token owner's address
     */
    'nonces(address)'(
      owner: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    'symbol()'(overrides?: CallOverrides): Promise<[string]>;

    /**
     * See {IERC20-totalSupply}.
     */
    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * See {IERC20-totalSupply}.
     */
    'totalSupply()'(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     */
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     */
    'transfer(address,uint256)'(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     */
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     */
    'transferFrom(address,address,uint256)'(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * meant to be called once immediately after deployment
     * Initialize the contract after it has been proxified
     */
    initialize(
      newName: string,
      newSymbol: string,
      newDecimals: BigNumberish,
      childChainManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * meant to be called once immediately after deployment
     * Initialize the contract after it has been proxified
     */
    'initialize(string,string,uint8,address)'(
      newName: string,
      newSymbol: string,
      newDecimals: BigNumberish,
      childChainManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    updateMetadata(
      newName: string,
      newSymbol: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    'updateMetadata(string,string)'(
      newName: string,
      newSymbol: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
     * called when token is deposited on root chain
     * @param depositData abi encoded amount
     * @param user user address for whom deposit is being done
     */
    deposit(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
     * called when token is deposited on root chain
     * @param depositData abi encoded amount
     * @param user user address for whom deposit is being done
     */
    'deposit(address,bytes)'(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Should burn user's tokens. This transaction will be verified when exiting on root chain
     * called when user wants to withdraw tokens back to root chain
     * @param amount amount of tokens to withdraw
     */
    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Should burn user's tokens. This transaction will be verified when exiting on root chain
     * called when user wants to withdraw tokens back to root chain
     * @param amount amount of tokens to withdraw
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Update allowance with a signed permit
     * @param deadline Expiration time, seconds since the epoch
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param value Amount of allowance
     */
    permit(
      owner: string,
      spender: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Update allowance with a signed permit
     * @param deadline Expiration time, seconds since the epoch
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param value Amount of allowance
     */
    'permit(address,address,uint256,uint256,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Execute a transfer with a signed authorization
     * @param from Payer's address (Authorizer)
     * @param nonce Unique nonce
     * @param r r of the signature
     * @param s s of the signature
     * @param to Payee's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be transferred
     */
    transferWithAuthorization(
      from: string,
      to: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Execute a transfer with a signed authorization
     * @param from Payer's address (Authorizer)
     * @param nonce Unique nonce
     * @param r r of the signature
     * @param s s of the signature
     * @param to Payee's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be transferred
     */
    'transferWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      from: string,
      to: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Update allowance with a signed authorization
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount of allowance
     */
    approveWithAuthorization(
      owner: string,
      spender: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Update allowance with a signed authorization
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount of allowance
     */
    'approveWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Increase allowance with a signed authorization
     * @param increment Amount of increase in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    increaseAllowanceWithAuthorization(
      owner: string,
      spender: string,
      increment: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Increase allowance with a signed authorization
     * @param increment Amount of increase in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    'increaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      increment: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Decrease allowance with a signed authorization
     * @param decrement Amount of decrease in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    decreaseAllowanceWithAuthorization(
      owner: string,
      spender: string,
      decrement: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Decrease allowance with a signed authorization
     * @param decrement Amount of decrease in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    'decreaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      decrement: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be withdrawn
     */
    withdrawWithAuthorization(
      owner: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be withdrawn
     */
    'withdrawWithAuthorization(address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Works only if the authorization is not yet used.
     * Attempt to cancel an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     */
    cancelAuthorization(
      authorizer: string,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Works only if the authorization is not yet used.
     * Attempt to cancel an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     */
    'cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)'(
      authorizer: string,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  APPROVE_WITH_AUTHORIZATION_TYPEHASH(
    overrides?: CallOverrides
  ): Promise<string>;

  'APPROVE_WITH_AUTHORIZATION_TYPEHASH()'(
    overrides?: CallOverrides
  ): Promise<string>;

  CANCEL_AUTHORIZATION_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  'CANCEL_AUTHORIZATION_TYPEHASH()'(overrides?: CallOverrides): Promise<string>;

  DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
    overrides?: CallOverrides
  ): Promise<string>;

  'DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
    overrides?: CallOverrides
  ): Promise<string>;

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

  DEPOSITOR_ROLE(overrides?: CallOverrides): Promise<string>;

  'DEPOSITOR_ROLE()'(overrides?: CallOverrides): Promise<string>;

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  'DOMAIN_SEPARATOR()'(overrides?: CallOverrides): Promise<string>;

  EIP712_VERSION(overrides?: CallOverrides): Promise<string>;

  'EIP712_VERSION()'(overrides?: CallOverrides): Promise<string>;

  INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
    overrides?: CallOverrides
  ): Promise<string>;

  'INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
    overrides?: CallOverrides
  ): Promise<string>;

  META_TRANSACTION_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  'META_TRANSACTION_TYPEHASH()'(overrides?: CallOverrides): Promise<string>;

  PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  'PERMIT_TYPEHASH()'(overrides?: CallOverrides): Promise<string>;

  TRANSFER_WITH_AUTHORIZATION_TYPEHASH(
    overrides?: CallOverrides
  ): Promise<string>;

  'TRANSFER_WITH_AUTHORIZATION_TYPEHASH()'(
    overrides?: CallOverrides
  ): Promise<string>;

  WITHDRAW_WITH_AUTHORIZATION_TYPEHASH(
    overrides?: CallOverrides
  ): Promise<string>;

  'WITHDRAW_WITH_AUTHORIZATION_TYPEHASH()'(
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * See {IERC20-allowance}.
   */
  allowance(
    owner: string,
    spender: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC20-allowance}.
   */
  'allowance(address,address)'(
    owner: string,
    spender: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
   */
  approve(
    spender: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
   */
  'approve(address,uint256)'(
    spender: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns the state of an authorization
   * @param authorizer Authorizer's address
   * @param nonce Nonce of the authorization
   */
  authorizationState(
    authorizer: string,
    nonce: BytesLike,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * Returns the state of an authorization
   * @param authorizer Authorizer's address
   * @param nonce Nonce of the authorization
   */
  'authorizationState(address,bytes32)'(
    authorizer: string,
    nonce: BytesLike,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * See {IERC20-balanceOf}.
   */
  balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * See {IERC20-balanceOf}.
   */
  'balanceOf(address)'(
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
   */
  decimals(overrides?: CallOverrides): Promise<number>;

  /**
   * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
   */
  'decimals()'(overrides?: CallOverrides): Promise<number>;

  /**
   * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
   */
  decreaseAllowance(
    spender: string,
    subtractedValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
   */
  'decreaseAllowance(address,uint256)'(
    spender: string,
    subtractedValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  executeMetaTransaction(
    userAddress: string,
    functionSignature: BytesLike,
    sigR: BytesLike,
    sigS: BytesLike,
    sigV: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)'(
    userAddress: string,
    functionSignature: BytesLike,
    sigR: BytesLike,
    sigS: BytesLike,
    sigV: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
   */
  'getRoleAdmin(bytes32)'(
    role: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
   */
  getRoleMember(
    role: BytesLike,
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
   */
  'getRoleMember(bytes32,uint256)'(
    role: BytesLike,
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
   */
  getRoleMemberCount(
    role: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
   */
  'getRoleMemberCount(bytes32)'(
    role: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  grantRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'grantRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  hasRole(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns `true` if `account` has been granted `role`.
   */
  'hasRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
   */
  increaseAllowance(
    spender: string,
    addedValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
   */
  'increaseAllowance(address,uint256)'(
    spender: string,
    addedValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  initialized(overrides?: CallOverrides): Promise<boolean>;

  'initialized()'(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Returns the name of the token.
   */
  name(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the name of the token.
   */
  'name()'(overrides?: CallOverrides): Promise<string>;

  /**
   * Nonces for permit / meta-transactions
   * @param owner Token owner's address
   */
  nonces(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Nonces for permit / meta-transactions
   * @param owner Token owner's address
   */
  'nonces(address)'(
    owner: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  renounceRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
   */
  'renounceRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  revokeRole(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
   */
  'revokeRole(bytes32,address)'(
    role: BytesLike,
    account: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns the symbol of the token, usually a shorter version of the name.
   */
  symbol(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the symbol of the token, usually a shorter version of the name.
   */
  'symbol()'(overrides?: CallOverrides): Promise<string>;

  /**
   * See {IERC20-totalSupply}.
   */
  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * See {IERC20-totalSupply}.
   */
  'totalSupply()'(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
   */
  transfer(
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
   */
  'transfer(address,uint256)'(
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
   */
  transferFrom(
    sender: string,
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
   */
  'transferFrom(address,address,uint256)'(
    sender: string,
    recipient: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * meant to be called once immediately after deployment
   * Initialize the contract after it has been proxified
   */
  initialize(
    newName: string,
    newSymbol: string,
    newDecimals: BigNumberish,
    childChainManager: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * meant to be called once immediately after deployment
   * Initialize the contract after it has been proxified
   */
  'initialize(string,string,uint8,address)'(
    newName: string,
    newSymbol: string,
    newDecimals: BigNumberish,
    childChainManager: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  updateMetadata(
    newName: string,
    newSymbol: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  'updateMetadata(string,string)'(
    newName: string,
    newSymbol: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
   * called when token is deposited on root chain
   * @param depositData abi encoded amount
   * @param user user address for whom deposit is being done
   */
  deposit(
    user: string,
    depositData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
   * called when token is deposited on root chain
   * @param depositData abi encoded amount
   * @param user user address for whom deposit is being done
   */
  'deposit(address,bytes)'(
    user: string,
    depositData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Should burn user's tokens. This transaction will be verified when exiting on root chain
   * called when user wants to withdraw tokens back to root chain
   * @param amount amount of tokens to withdraw
   */
  withdraw(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Should burn user's tokens. This transaction will be verified when exiting on root chain
   * called when user wants to withdraw tokens back to root chain
   * @param amount amount of tokens to withdraw
   */
  'withdraw(uint256)'(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Update allowance with a signed permit
   * @param deadline Expiration time, seconds since the epoch
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param spender Spender's address
   * @param v v of the signature
   * @param value Amount of allowance
   */
  permit(
    owner: string,
    spender: string,
    value: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Update allowance with a signed permit
   * @param deadline Expiration time, seconds since the epoch
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param spender Spender's address
   * @param v v of the signature
   * @param value Amount of allowance
   */
  'permit(address,address,uint256,uint256,uint8,bytes32,bytes32)'(
    owner: string,
    spender: string,
    value: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Execute a transfer with a signed authorization
   * @param from Payer's address (Authorizer)
   * @param nonce Unique nonce
   * @param r r of the signature
   * @param s s of the signature
   * @param to Payee's address
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   * @param value Amount to be transferred
   */
  transferWithAuthorization(
    from: string,
    to: string,
    value: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Execute a transfer with a signed authorization
   * @param from Payer's address (Authorizer)
   * @param nonce Unique nonce
   * @param r r of the signature
   * @param s s of the signature
   * @param to Payee's address
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   * @param value Amount to be transferred
   */
  'transferWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
    from: string,
    to: string,
    value: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Update allowance with a signed authorization
   * @param nonce Unique nonce
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param spender Spender's address
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   * @param value Amount of allowance
   */
  approveWithAuthorization(
    owner: string,
    spender: string,
    value: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Update allowance with a signed authorization
   * @param nonce Unique nonce
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param spender Spender's address
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   * @param value Amount of allowance
   */
  'approveWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
    owner: string,
    spender: string,
    value: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Increase allowance with a signed authorization
   * @param increment Amount of increase in allowance
   * @param nonce Unique nonce
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param spender Spender's address
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   */
  increaseAllowanceWithAuthorization(
    owner: string,
    spender: string,
    increment: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Increase allowance with a signed authorization
   * @param increment Amount of increase in allowance
   * @param nonce Unique nonce
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param spender Spender's address
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   */
  'increaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
    owner: string,
    spender: string,
    increment: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Decrease allowance with a signed authorization
   * @param decrement Amount of decrease in allowance
   * @param nonce Unique nonce
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param spender Spender's address
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   */
  decreaseAllowanceWithAuthorization(
    owner: string,
    spender: string,
    decrement: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Decrease allowance with a signed authorization
   * @param decrement Amount of decrease in allowance
   * @param nonce Unique nonce
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param spender Spender's address
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   */
  'decreaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
    owner: string,
    spender: string,
    decrement: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
   * @param nonce Unique nonce
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   * @param value Amount to be withdrawn
   */
  withdrawWithAuthorization(
    owner: string,
    value: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
   * @param nonce Unique nonce
   * @param owner Token owner's address (Authorizer)
   * @param r r of the signature
   * @param s s of the signature
   * @param v v of the signature
   * @param validAfter The time after which this is valid (unix time)
   * @param validBefore The time before which this is valid (unix time)
   * @param value Amount to be withdrawn
   */
  'withdrawWithAuthorization(address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
    owner: string,
    value: BigNumberish,
    validAfter: BigNumberish,
    validBefore: BigNumberish,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Works only if the authorization is not yet used.
   * Attempt to cancel an authorization
   * @param authorizer Authorizer's address
   * @param nonce Nonce of the authorization
   * @param r r of the signature
   * @param s s of the signature
   * @param v v of the signature
   */
  cancelAuthorization(
    authorizer: string,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Works only if the authorization is not yet used.
   * Attempt to cancel an authorization
   * @param authorizer Authorizer's address
   * @param nonce Nonce of the authorization
   * @param r r of the signature
   * @param s s of the signature
   * @param v v of the signature
   */
  'cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)'(
    authorizer: string,
    nonce: BytesLike,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    APPROVE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<string>;

    'APPROVE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<string>;

    CANCEL_AUTHORIZATION_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    'CANCEL_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<string>;

    DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<string>;

    'DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<string>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<string>;

    DEPOSITOR_ROLE(overrides?: CallOverrides): Promise<string>;

    'DEPOSITOR_ROLE()'(overrides?: CallOverrides): Promise<string>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    'DOMAIN_SEPARATOR()'(overrides?: CallOverrides): Promise<string>;

    EIP712_VERSION(overrides?: CallOverrides): Promise<string>;

    'EIP712_VERSION()'(overrides?: CallOverrides): Promise<string>;

    INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<string>;

    'INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<string>;

    META_TRANSACTION_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    'META_TRANSACTION_TYPEHASH()'(overrides?: CallOverrides): Promise<string>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    'PERMIT_TYPEHASH()'(overrides?: CallOverrides): Promise<string>;

    TRANSFER_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<string>;

    'TRANSFER_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<string>;

    WITHDRAW_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<string>;

    'WITHDRAW_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * See {IERC20-allowance}.
     */
    allowance(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC20-allowance}.
     */
    'allowance(address,address)'(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
     */
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
     */
    'approve(address,uint256)'(
      spender: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns the state of an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     */
    authorizationState(
      authorizer: string,
      nonce: BytesLike,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * Returns the state of an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     */
    'authorizationState(address,bytes32)'(
      authorizer: string,
      nonce: BytesLike,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * See {IERC20-balanceOf}.
     */
    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC20-balanceOf}.
     */
    'balanceOf(address)'(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    decimals(overrides?: CallOverrides): Promise<number>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    'decimals()'(overrides?: CallOverrides): Promise<number>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    'decreaseAllowance(address,uint256)'(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    executeMetaTransaction(
      userAddress: string,
      functionSignature: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    'executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)'(
      userAddress: string,
      functionSignature: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    getRoleMember(
      role: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    'getRoleMember(bytes32,uint256)'(
      role: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    getRoleMemberCount(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    'getRoleMemberCount(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    'increaseAllowance(address,uint256)'(
      spender: string,
      addedValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    initialized(overrides?: CallOverrides): Promise<boolean>;

    'initialized()'(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Returns the name of the token.
     */
    name(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the name of the token.
     */
    'name()'(overrides?: CallOverrides): Promise<string>;

    /**
     * Nonces for permit / meta-transactions
     * @param owner Token owner's address
     */
    nonces(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Nonces for permit / meta-transactions
     * @param owner Token owner's address
     */
    'nonces(address)'(
      owner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    'symbol()'(overrides?: CallOverrides): Promise<string>;

    /**
     * See {IERC20-totalSupply}.
     */
    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC20-totalSupply}.
     */
    'totalSupply()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     */
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     */
    'transfer(address,uint256)'(
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     */
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     */
    'transferFrom(address,address,uint256)'(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * meant to be called once immediately after deployment
     * Initialize the contract after it has been proxified
     */
    initialize(
      newName: string,
      newSymbol: string,
      newDecimals: BigNumberish,
      childChainManager: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * meant to be called once immediately after deployment
     * Initialize the contract after it has been proxified
     */
    'initialize(string,string,uint8,address)'(
      newName: string,
      newSymbol: string,
      newDecimals: BigNumberish,
      childChainManager: string,
      overrides?: CallOverrides
    ): Promise<void>;

    updateMetadata(
      newName: string,
      newSymbol: string,
      overrides?: CallOverrides
    ): Promise<void>;

    'updateMetadata(string,string)'(
      newName: string,
      newSymbol: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
     * called when token is deposited on root chain
     * @param depositData abi encoded amount
     * @param user user address for whom deposit is being done
     */
    deposit(
      user: string,
      depositData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
     * called when token is deposited on root chain
     * @param depositData abi encoded amount
     * @param user user address for whom deposit is being done
     */
    'deposit(address,bytes)'(
      user: string,
      depositData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Should burn user's tokens. This transaction will be verified when exiting on root chain
     * called when user wants to withdraw tokens back to root chain
     * @param amount amount of tokens to withdraw
     */
    withdraw(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Should burn user's tokens. This transaction will be verified when exiting on root chain
     * called when user wants to withdraw tokens back to root chain
     * @param amount amount of tokens to withdraw
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Update allowance with a signed permit
     * @param deadline Expiration time, seconds since the epoch
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param value Amount of allowance
     */
    permit(
      owner: string,
      spender: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Update allowance with a signed permit
     * @param deadline Expiration time, seconds since the epoch
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param value Amount of allowance
     */
    'permit(address,address,uint256,uint256,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Execute a transfer with a signed authorization
     * @param from Payer's address (Authorizer)
     * @param nonce Unique nonce
     * @param r r of the signature
     * @param s s of the signature
     * @param to Payee's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be transferred
     */
    transferWithAuthorization(
      from: string,
      to: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Execute a transfer with a signed authorization
     * @param from Payer's address (Authorizer)
     * @param nonce Unique nonce
     * @param r r of the signature
     * @param s s of the signature
     * @param to Payee's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be transferred
     */
    'transferWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      from: string,
      to: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Update allowance with a signed authorization
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount of allowance
     */
    approveWithAuthorization(
      owner: string,
      spender: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Update allowance with a signed authorization
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount of allowance
     */
    'approveWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Increase allowance with a signed authorization
     * @param increment Amount of increase in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    increaseAllowanceWithAuthorization(
      owner: string,
      spender: string,
      increment: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Increase allowance with a signed authorization
     * @param increment Amount of increase in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    'increaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      increment: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Decrease allowance with a signed authorization
     * @param decrement Amount of decrease in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    decreaseAllowanceWithAuthorization(
      owner: string,
      spender: string,
      decrement: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Decrease allowance with a signed authorization
     * @param decrement Amount of decrease in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    'decreaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      decrement: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be withdrawn
     */
    withdrawWithAuthorization(
      owner: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be withdrawn
     */
    'withdrawWithAuthorization(address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Works only if the authorization is not yet used.
     * Attempt to cancel an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     */
    cancelAuthorization(
      authorizer: string,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Works only if the authorization is not yet used.
     * Attempt to cancel an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     */
    'cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)'(
      authorizer: string,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    'Approval(address,address,uint256)'(
      owner?: string | null,
      spender?: string | null,
      value?: null
    ): ApprovalEventFilter;
    Approval(
      owner?: string | null,
      spender?: string | null,
      value?: null
    ): ApprovalEventFilter;

    'AuthorizationCanceled(address,bytes32)'(
      authorizer?: string | null,
      nonce?: BytesLike | null
    ): AuthorizationCanceledEventFilter;
    AuthorizationCanceled(
      authorizer?: string | null,
      nonce?: BytesLike | null
    ): AuthorizationCanceledEventFilter;

    'AuthorizationUsed(address,bytes32)'(
      authorizer?: string | null,
      nonce?: BytesLike | null
    ): AuthorizationUsedEventFilter;
    AuthorizationUsed(
      authorizer?: string | null,
      nonce?: BytesLike | null
    ): AuthorizationUsedEventFilter;

    'MetaTransactionExecuted(address,address,bytes)'(
      userAddress?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;
    MetaTransactionExecuted(
      userAddress?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;

    'RoleAdminChanged(bytes32,bytes32,bytes32)'(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: BytesLike | null,
      previousAdminRole?: BytesLike | null,
      newAdminRole?: BytesLike | null
    ): RoleAdminChangedEventFilter;

    'RoleGranted(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleGrantedEventFilter;

    'RoleRevoked(bytes32,address,address)'(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: BytesLike | null,
      account?: string | null,
      sender?: string | null
    ): RoleRevokedEventFilter;

    'Transfer(address,address,uint256)'(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TransferEventFilter;
    Transfer(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TransferEventFilter;
  };

  estimateGas: {
    APPROVE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'APPROVE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    CANCEL_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'CANCEL_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    'DEFAULT_ADMIN_ROLE()'(overrides?: CallOverrides): Promise<BigNumber>;

    DEPOSITOR_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    'DEPOSITOR_ROLE()'(overrides?: CallOverrides): Promise<BigNumber>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    'DOMAIN_SEPARATOR()'(overrides?: CallOverrides): Promise<BigNumber>;

    EIP712_VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    'EIP712_VERSION()'(overrides?: CallOverrides): Promise<BigNumber>;

    INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    META_TRANSACTION_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    'META_TRANSACTION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    'PERMIT_TYPEHASH()'(overrides?: CallOverrides): Promise<BigNumber>;

    TRANSFER_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'TRANSFER_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    WITHDRAW_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    'WITHDRAW_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC20-allowance}.
     */
    allowance(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC20-allowance}.
     */
    'allowance(address,address)'(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
     */
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
     */
    'approve(address,uint256)'(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns the state of an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     */
    authorizationState(
      authorizer: string,
      nonce: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the state of an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     */
    'authorizationState(address,bytes32)'(
      authorizer: string,
      nonce: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * See {IERC20-balanceOf}.
     */
    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC20-balanceOf}.
     */
    'balanceOf(address)'(
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    'decimals()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    'decreaseAllowance(address,uint256)'(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    executeMetaTransaction(
      userAddress: string,
      functionSignature: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)'(
      userAddress: string,
      functionSignature: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    getRoleMember(
      role: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    'getRoleMember(bytes32,uint256)'(
      role: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    getRoleMemberCount(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    'getRoleMemberCount(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    'increaseAllowance(address,uint256)'(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    initialized(overrides?: CallOverrides): Promise<BigNumber>;

    'initialized()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the name of the token.
     */
    name(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the name of the token.
     */
    'name()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Nonces for permit / meta-transactions
     * @param owner Token owner's address
     */
    nonces(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Nonces for permit / meta-transactions
     * @param owner Token owner's address
     */
    'nonces(address)'(
      owner: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    'symbol()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC20-totalSupply}.
     */
    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC20-totalSupply}.
     */
    'totalSupply()'(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     */
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     */
    'transfer(address,uint256)'(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     */
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     */
    'transferFrom(address,address,uint256)'(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * meant to be called once immediately after deployment
     * Initialize the contract after it has been proxified
     */
    initialize(
      newName: string,
      newSymbol: string,
      newDecimals: BigNumberish,
      childChainManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * meant to be called once immediately after deployment
     * Initialize the contract after it has been proxified
     */
    'initialize(string,string,uint8,address)'(
      newName: string,
      newSymbol: string,
      newDecimals: BigNumberish,
      childChainManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    updateMetadata(
      newName: string,
      newSymbol: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    'updateMetadata(string,string)'(
      newName: string,
      newSymbol: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
     * called when token is deposited on root chain
     * @param depositData abi encoded amount
     * @param user user address for whom deposit is being done
     */
    deposit(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
     * called when token is deposited on root chain
     * @param depositData abi encoded amount
     * @param user user address for whom deposit is being done
     */
    'deposit(address,bytes)'(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Should burn user's tokens. This transaction will be verified when exiting on root chain
     * called when user wants to withdraw tokens back to root chain
     * @param amount amount of tokens to withdraw
     */
    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Should burn user's tokens. This transaction will be verified when exiting on root chain
     * called when user wants to withdraw tokens back to root chain
     * @param amount amount of tokens to withdraw
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Update allowance with a signed permit
     * @param deadline Expiration time, seconds since the epoch
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param value Amount of allowance
     */
    permit(
      owner: string,
      spender: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Update allowance with a signed permit
     * @param deadline Expiration time, seconds since the epoch
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param value Amount of allowance
     */
    'permit(address,address,uint256,uint256,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Execute a transfer with a signed authorization
     * @param from Payer's address (Authorizer)
     * @param nonce Unique nonce
     * @param r r of the signature
     * @param s s of the signature
     * @param to Payee's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be transferred
     */
    transferWithAuthorization(
      from: string,
      to: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Execute a transfer with a signed authorization
     * @param from Payer's address (Authorizer)
     * @param nonce Unique nonce
     * @param r r of the signature
     * @param s s of the signature
     * @param to Payee's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be transferred
     */
    'transferWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      from: string,
      to: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Update allowance with a signed authorization
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount of allowance
     */
    approveWithAuthorization(
      owner: string,
      spender: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Update allowance with a signed authorization
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount of allowance
     */
    'approveWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Increase allowance with a signed authorization
     * @param increment Amount of increase in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    increaseAllowanceWithAuthorization(
      owner: string,
      spender: string,
      increment: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Increase allowance with a signed authorization
     * @param increment Amount of increase in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    'increaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      increment: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Decrease allowance with a signed authorization
     * @param decrement Amount of decrease in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    decreaseAllowanceWithAuthorization(
      owner: string,
      spender: string,
      decrement: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Decrease allowance with a signed authorization
     * @param decrement Amount of decrease in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    'decreaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      decrement: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be withdrawn
     */
    withdrawWithAuthorization(
      owner: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be withdrawn
     */
    'withdrawWithAuthorization(address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Works only if the authorization is not yet used.
     * Attempt to cancel an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     */
    cancelAuthorization(
      authorizer: string,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Works only if the authorization is not yet used.
     * Attempt to cancel an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     */
    'cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)'(
      authorizer: string,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    APPROVE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'APPROVE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    CANCEL_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'CANCEL_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'DEFAULT_ADMIN_ROLE()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DEPOSITOR_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'DEPOSITOR_ROLE()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'DOMAIN_SEPARATOR()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    EIP712_VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'EIP712_VERSION()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    META_TRANSACTION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'META_TRANSACTION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    PERMIT_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'PERMIT_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    TRANSFER_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'TRANSFER_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    WITHDRAW_WITH_AUTHORIZATION_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    'WITHDRAW_WITH_AUTHORIZATION_TYPEHASH()'(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-allowance}.
     */
    allowance(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-allowance}.
     */
    'allowance(address,address)'(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
     */
    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.
     */
    'approve(address,uint256)'(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the state of an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     */
    authorizationState(
      authorizer: string,
      nonce: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the state of an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     */
    'authorizationState(address,bytes32)'(
      authorizer: string,
      nonce: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-balanceOf}.
     */
    balanceOf(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-balanceOf}.
     */
    'balanceOf(address)'(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.
     */
    'decimals()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.
     */
    'decreaseAllowance(address,uint256)'(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    executeMetaTransaction(
      userAddress: string,
      functionSignature: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)'(
      userAddress: string,
      functionSignature: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    'getRoleAdmin(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    getRoleMember(
      role: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    'getRoleMember(bytes32,uint256)'(
      role: BytesLike,
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    getRoleMemberCount(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    'getRoleMemberCount(bytes32)'(
      role: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'grantRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns `true` if `account` has been granted `role`.
     */
    'hasRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.
     */
    'increaseAllowance(address,uint256)'(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    initialized(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    'initialized()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the name of the token.
     */
    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the name of the token.
     */
    'name()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Nonces for permit / meta-transactions
     * @param owner Token owner's address
     */
    nonces(
      owner: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Nonces for permit / meta-transactions
     * @param owner Token owner's address
     */
    'nonces(address)'(
      owner: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    'renounceRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    'revokeRole(bytes32,address)'(
      role: BytesLike,
      account: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    'symbol()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-totalSupply}.
     */
    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-totalSupply}.
     */
    'totalSupply()'(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     */
    transfer(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.
     */
    'transfer(address,uint256)'(
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     */
    transferFrom(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}; Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.
     */
    'transferFrom(address,address,uint256)'(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * meant to be called once immediately after deployment
     * Initialize the contract after it has been proxified
     */
    initialize(
      newName: string,
      newSymbol: string,
      newDecimals: BigNumberish,
      childChainManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * meant to be called once immediately after deployment
     * Initialize the contract after it has been proxified
     */
    'initialize(string,string,uint8,address)'(
      newName: string,
      newSymbol: string,
      newDecimals: BigNumberish,
      childChainManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    updateMetadata(
      newName: string,
      newSymbol: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    'updateMetadata(string,string)'(
      newName: string,
      newSymbol: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
     * called when token is deposited on root chain
     * @param depositData abi encoded amount
     * @param user user address for whom deposit is being done
     */
    deposit(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Should be callable only by ChildChainManager Should handle deposit by minting the required amount for user Make sure minting is done only by this function
     * called when token is deposited on root chain
     * @param depositData abi encoded amount
     * @param user user address for whom deposit is being done
     */
    'deposit(address,bytes)'(
      user: string,
      depositData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Should burn user's tokens. This transaction will be verified when exiting on root chain
     * called when user wants to withdraw tokens back to root chain
     * @param amount amount of tokens to withdraw
     */
    withdraw(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Should burn user's tokens. This transaction will be verified when exiting on root chain
     * called when user wants to withdraw tokens back to root chain
     * @param amount amount of tokens to withdraw
     */
    'withdraw(uint256)'(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Update allowance with a signed permit
     * @param deadline Expiration time, seconds since the epoch
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param value Amount of allowance
     */
    permit(
      owner: string,
      spender: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Update allowance with a signed permit
     * @param deadline Expiration time, seconds since the epoch
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param value Amount of allowance
     */
    'permit(address,address,uint256,uint256,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Execute a transfer with a signed authorization
     * @param from Payer's address (Authorizer)
     * @param nonce Unique nonce
     * @param r r of the signature
     * @param s s of the signature
     * @param to Payee's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be transferred
     */
    transferWithAuthorization(
      from: string,
      to: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Execute a transfer with a signed authorization
     * @param from Payer's address (Authorizer)
     * @param nonce Unique nonce
     * @param r r of the signature
     * @param s s of the signature
     * @param to Payee's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be transferred
     */
    'transferWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      from: string,
      to: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Update allowance with a signed authorization
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount of allowance
     */
    approveWithAuthorization(
      owner: string,
      spender: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Update allowance with a signed authorization
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount of allowance
     */
    'approveWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Increase allowance with a signed authorization
     * @param increment Amount of increase in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    increaseAllowanceWithAuthorization(
      owner: string,
      spender: string,
      increment: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Increase allowance with a signed authorization
     * @param increment Amount of increase in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    'increaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      increment: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Decrease allowance with a signed authorization
     * @param decrement Amount of decrease in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    decreaseAllowanceWithAuthorization(
      owner: string,
      spender: string,
      decrement: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Decrease allowance with a signed authorization
     * @param decrement Amount of decrease in allowance
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param spender Spender's address
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     */
    'decreaseAllowanceWithAuthorization(address,address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      spender: string,
      decrement: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be withdrawn
     */
    withdrawWithAuthorization(
      owner: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Execute a withdrawal with a signed authorization. This is used to transfer tokens back to the root chain.
     * @param nonce Unique nonce
     * @param owner Token owner's address (Authorizer)
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     * @param validAfter The time after which this is valid (unix time)
     * @param validBefore The time before which this is valid (unix time)
     * @param value Amount to be withdrawn
     */
    'withdrawWithAuthorization(address,uint256,uint256,uint256,bytes32,uint8,bytes32,bytes32)'(
      owner: string,
      value: BigNumberish,
      validAfter: BigNumberish,
      validBefore: BigNumberish,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Works only if the authorization is not yet used.
     * Attempt to cancel an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     */
    cancelAuthorization(
      authorizer: string,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Works only if the authorization is not yet used.
     * Attempt to cancel an authorization
     * @param authorizer Authorizer's address
     * @param nonce Nonce of the authorization
     * @param r r of the signature
     * @param s s of the signature
     * @param v v of the signature
     */
    'cancelAuthorization(address,bytes32,uint8,bytes32,bytes32)'(
      authorizer: string,
      nonce: BytesLike,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
